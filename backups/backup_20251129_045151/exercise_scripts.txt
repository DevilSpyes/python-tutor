.
Módulo 00: Bienvenida y Guía.

Hola y bienvenido o bienvenida al Curso de Python orientado a Ciberseguridad. Soy Carlos Domínguez, y junto con la asistencia de inteligencia artificial generativa, he diseñado esta plataforma para ti.

Bienvenido, operador. Has accedido al entorno de entrenamiento donde desarrollarás habilidades reales en Python, desde cero absoluto hasta un nivel avanzado. Nuestro enfoque se especializa en Automatización, Ciberseguridad y Criptografía, Análisis técnico y la creación de herramientas operativas.

Aquí no solo vas a programar: vas a aprender a pensar como un analista, como un desarrollador y como un hacker ético.

¿Qué encontrarás en este curso? Cada módulo incluye explicaciones claras, ejemplos reales, ejercicios interactivos y código que verás escribirse en tiempo real, al estilo de una terminal. También enfrentarás retos prácticos y mini-proyectos progresivos.

Cuando completes este protocolo de entrenamiento serás capaz de dominar la sintaxis esencial de Python, automatizar procesos reales, crear herramientas funcionales, escribir scripts de seguridad, analizar código para resolver problemas y construir proyectos completos.

Sobre la filosofía del curso: Este curso es cien por cien gratuito. Nace con el propósito de compartir conocimiento y ayudarte a desarrollar habilidades tecnológicas reales. Tú controlas el ritmo. Tu progreso no depende de memorizar, sino de experimentar.

Te daré tres recomendaciones clave: Primero, usa herramientas reales como VSCode, PyCharm o Thonny. Segundo, experimenta sin miedo: rompe el código, repáralo, vuelve a romperlo y aprende en el proceso. Y tercero, construye constancia: veinte minutos al día te llevarán lejos.

Finalmente, este es nuestro plan de estudios definitivo: Comenzamos con el Módulo 00 de Bienvenida. Seguiremos con la Introducción en el Módulo 01 y los Conceptos Fundamentales en el Módulo 02. En el Módulo 03 practicaremos Algoritmos, y en el 04 nos centraremos en Automatización y Scripts. El Módulo 05 cubre Ciberseguridad y Criptografía, el 06 los Proyectos Finales, y terminaremos con la Certificación en el Módulo 07.

Pasemos al siguiente ejercicio.

.
Módulo 01: Introducción
.

Pasemos al siguiente ejercicio.

Lección: Hola Mundo y Print.

El objetivo de este ejercicio es:
Escribir y ejecutar tu primer programa en Python, aprendiendo a mostrar información en la consola.

En esta lección aprenderemos:
Uso de la función print().
Manejo de cadenas de texto (strings) con comillas simples, dobles y triples.
Parámetros sep y end para controlar el formato de salida.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código tal como está para ver el saludo inicial.
Paso 2: Modifica el mensaje dentro de print() para que diga tu nombre.
Paso 3: Experimenta cambiando el separador sep="-" por otro carácter.

Permíteme explicarte más detalles.
Comencemos con una de las funciones más esenciales en Python: la función print. Esta función nos permite mostrar información en la consola y será su compañera constante a lo largo de su vida como programadores.

En este primer ejemplo, observamos cómo imprimir un texto básico. Noten que también es posible utilizar comillas simples para delimitar el texto. Además, la función print nos permite imprimir múltiples elementos separándolos por comas.

Existen parámetros útiles como sep, que define cómo se separan los elementos impresos, y end, que determina qué carácter se imprime al final de la línea. Por defecto, print añade un salto de línea, pero podemos modificar este comportamiento.

Pasemos al siguiente ejercicio.

Lección: Tipos de Datos.

El objetivo de este ejercicio es:
Identificar y diferenciar los tipos de datos fundamentales en Python.

En esta lección aprenderemos:
Enteros (int), Flotantes (float), Complejos (complex).
Cadenas de texto (str) y Booleanos (bool).
Uso de la función type() para inspeccionar datos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para ver los tipos de datos de cada ejemplo.
Paso 2: Intenta crear una nueva variable con un número decimal y verifica su tipo con type().
Paso 3: Observa la diferencia entre 10 (int) y "10" (str).

Permíteme explicarte más detalles.
Python maneja diversos tipos de datos. La función type es muy útil para identificar el tipo de un objeto.

Tenemos los números enteros, conocidos como int, que no tienen parte decimal. Pueden ser positivos, negativos o incluso el cero. Python es capaz de manejar enteros de gran tamaño sin problemas.

Luego están los números de punto flotante, o float, que son números con decimales. También podemos usar notación científica para representarlos.

Pasemos al siguiente ejercicio.

Lección: Conversión de Tipos, también conocido como Casting.

El objetivo de este ejercicio es aprender a transformar valores de un tipo de dato a otro.

En esta lección aprenderemos:
Las funciones de conversión: int, float y string.
Comportamiento al convertir decimales a enteros (truncamiento).
Evaluación de verdad (Truthiness) de diferentes valores.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código y analiza cómo cambian los valores tras la conversión.
Paso 2: Intenta sumar el número 5 con la cadena "5" sin convertirla y observa el error.
Paso 3: Corrige el error anterior usando int("5").

Permíteme explicarte más detalles.
A menudo necesitamos transformar un valor de un tipo a otro. Esto se conoce como "casting".

Por ejemplo, si tenemos una cadena que contiene un número, podemos convertirla a entero usando int para realizar operaciones matemáticas. De igual forma, podemos convertir un número a cadena usando str para concatenarlo con texto.

Podemos convertir cadenas a números decimales con float. Si convertimos un decimal a entero, la parte decimal se truncará.

Pasemos al siguiente ejercicio.

Lección: Variables.

El objetivo de este ejercicio es:
Entender cómo almacenar y manipular datos en memoria usando variables.

En esta lección aprenderemos:
Asignación y reasignación de variables.
Tipado dinámico vs. Tipado fuerte.
Convenciones de nombres (snake_case) y palabras reservadas.
Uso de f-strings para formatear texto con variables.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Crea una variable con tu nombre y otra con tu edad.
Paso 2: Usa una f-string para imprimir una frase presentándote.
Paso 3: Intenta sumar tu nombre (str) con tu edad (int) y observa el error de tipado fuerte.

Permíteme explicarte más detalles.
Las variables son contenedores que nos permiten guardar datos en la memoria. Python es un lenguaje de tipado dinámico, lo que significa que no necesitamos declarar el tipo de variable explícitamente; el intérprete lo deduce en tiempo de ejecución.

Para asignar una variable, simplemente escribimos su nombre y le damos un valor. Podemos reasignar un nuevo valor a una variable existente en cualquier momento.

Python también es de tipado fuerte, lo que significa que no realiza conversiones automáticas de tipo que puedan perder información o causar ambigüedad.

Pasemos al siguiente ejercicio.

Lección: Entrada de Datos (Input).

El objetivo de este ejercicio es:
Interactuar con el usuario recibiendo datos desde la consola.

En esta lección aprenderemos:
Uso de la función input().
Los datos recibidos siempre son cadenas (str).
Conversión necesaria para trabajar con números ingresados.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código. Nota que los valores están "hardcodeados" para la demo.
Paso 2: Descomenta las líneas con input() para probar la interacción real.
Paso 3: Escribe un programa que pida dos números y muestre su suma.

Permíteme explicarte más detalles.
La función input nos permite interactuar con el usuario obteniendo datos desde la consola. Esta función muestra un mensaje y espera a que el usuario escriba algo y presione Enter.

Es crucial recordar que input siempre devuelve una cadena de texto. Si necesitamos un número, debemos convertir esa cadena explícitamente.

Pasemos al siguiente ejercicio.

Lección: Ejercicios Básicos.

El objetivo de este ejercicio es:
Poner a prueba los conocimientos adquiridos en el módulo mediante retos prácticos.

En esta lección aprenderemos:
Consolidación de print, variables, tipos y casting.
Resolución de problemas simples.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Completa el Ejercicio 1 imprimiendo tu nombre y ciudad.
Paso 2: En el Ejercicio 2, usa type() para identificar las variables.
Paso 3: Realiza las conversiones pedidas en el Ejercicio 3.
Paso 4: Crea tu presentación personal en el Ejercicio 4.
Paso 5: Realiza los cálculos matemáticos del Ejercicio 5.

Permíteme explicarte más detalles.
Es momento de poner en práctica lo aprendido. En este archivo exercises.py encontrarán una serie de retos.

Deberán imprimir mensajes, determinar tipos de datos, realizar conversiones de tipos y trabajar con variables y f-strings. También practicarán operaciones numéricas básicas.

Pasemos al siguiente ejercicio.

Lección: Condicionales (If).

El objetivo de este ejercicio es:
Controlar el flujo del programa tomando decisiones basadas en condiciones.

En esta lección aprenderemos:
Estructuras if, elif, else.
Operadores de comparación y lógicos (and, or, not).
Indentación como bloque de código.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Modifica la variable edad y observa qué mensaje se imprime.
Paso 2: Crea una condición que verifique si un número es par (usando % 2 == 0).
Paso 3: Prueba la condición ternaria en una sola línea.

Permíteme explicarte más detalles.
Las sentencias condicionales nos permiten controlar el flujo del programa. Usamos if para ejecutar un bloque de código solo si se cumple una condición.

Si la condición no se cumple, podemos usar else para ejecutar un bloque alternativo. Para evaluar múltiples condiciones en secuencia, utilizamos elif.

Pasemos al siguiente ejercicio.

Lección: Booleanos.

El objetivo de este ejercicio es:
Comprender la lógica booleana y las tablas de verdad.

En esta lección aprenderemos:
Valores True y False.
Resultado de comparaciones (>, <, ==, !=).
Lógica combinatoria.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código y analiza los resultados de las comparaciones.
Paso 2: Predice el resultado de True and False antes de ejecutarlo.
Paso 3: Crea una expresión compleja combinando and, or y not.

Permíteme explicarte más detalles.
Los booleanos son fundamentales para la lógica de programación. Representan los valores de verdad: True y False.

Los operadores de comparación, como mayor que, menor que, igual o diferente, siempre devuelven un valor booleano.

Pasemos al siguiente ejercicio.

Lección: Listas.

El objetivo de este ejercicio es:
Almacenar y manipular colecciones ordenadas de elementos.

En esta lección aprenderemos:
Creación de listas.
Acceso por índice (positivo y negativo).
Slicing (rebanado) para obtener sublistas.
Modificación de elementos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Crea una lista con tus 3 películas favoritas.
Paso 2: Imprime la primera y la última película usando índices.
Paso 3: Usa slicing para imprimir solo las dos primeras.

Permíteme explicarte más detalles.
Las listas son secuencias mutables de elementos. Pueden contener elementos de cualquier tipo, incluso mezclados.

Podemos acceder a los elementos de una lista mediante su índice, empezando por el cero. Los índices negativos nos permiten acceder desde el final.

Pasemos al siguiente ejercicio.

Lección: Métodos de Listas.

El objetivo de este ejercicio es:
Dominar las herramientas integradas para modificar y gestionar listas.

En esta lección aprenderemos:
Añadir elementos: append, insert, extend.
Eliminar elementos: remove, pop, clear.
Ordenar (sort) y buscar (index, count).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Resuelve el Ejercicio 1 añadiendo y modificando elementos.
Paso 2: Practica la eliminación en el Ejercicio 2 y 3.
Paso 3: Ordena la lista numérica en el Ejercicio 4.
Paso 4: Entiende la diferencia entre copia y referencia en el Ejercicio 5.

Permíteme explicarte más detalles.
Python nos ofrece métodos potentes para trabajar con listas.

append añade un elemento al final, mientras que insert lo coloca en una posición específica. extend nos permite agregar múltiples elementos de otra lista.

Para eliminar, tenemos remove, que borra la primera aparición de un valor, y pop, que elimina y devuelve un elemento por su índice.

Pasemos al siguiente ejercicio.

Lección: Bucle While.

El objetivo de este ejercicio es:
Ejecutar código repetidamente basándose en una condición lógica.

En esta lección aprenderemos:
Sintaxis while.
Evitar bucles infinitos.
Control de flujo con break y continue.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el ejemplo del contador.
Paso 2: Intenta escribir un bucle que cuente de 2 en 2 hasta 20.
Paso 3: Resuelve el ejercicio de "Validación de contraseña" usando un while.

Permíteme explicarte más detalles.
El bucle while permite ejecutar un bloque de código repetidamente mientras se cumpla una condición. Es vital asegurarse de que la condición eventualmente sea falsa para evitar bucles infinitos.

La sentencia break nos permite salir del bucle inmediatamente, mientras que continue salta a la siguiente iteración.

Pasemos al siguiente ejercicio.

Lección: Bucle For.

El objetivo de este ejercicio es:
Iterar eficientemente sobre secuencias y colecciones.

En esta lección aprenderemos:
Iteración sobre listas y cadenas.
Uso de enumerate() para obtener índice y valor.
List Comprehensions (Comprensión de listas) para código conciso.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Itera sobre la lista de frutas e imprime cada una.
Paso 2: Usa enumerate para imprimir la posición de cada fruta.
Paso 3: Convierte el bucle de "números pares" en una List Comprehension.

Permíteme explicarte más detalles.
El bucle for es ideal para iterar sobre secuencias, como listas o cadenas de texto.

La función enumerate es muy útil cuando necesitamos tanto el índice como el valor del elemento.

Podemos anidar bucles for, aunque debemos tener cuidado con la complejidad.

Pasemos al siguiente ejercicio.

Lección: Rango (Range).

El objetivo de este ejercicio es:
Generar secuencias numéricas para controlar bucles.

En esta lección aprenderemos:
Función range(inicio, fin, paso).
Generación de secuencias inversas.
Uso común en bucles for.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Imprime los números del 0 al 9 usando range(10).
Paso 2: Genera una cuenta regresiva del 10 al 1.
Paso 3: Resuelve el ejercicio de la tabla de multiplicar usando range.

Permíteme explicarte más detalles.
La función range genera una secuencia de números, lo cual es extremadamente útil en bucles for.

Podemos especificar el inicio, el fin y el paso de la secuencia. Recuerden que el valor final no se incluye en la secuencia.

Pasemos al siguiente ejercicio.

Lección: Funciones.

El objetivo de este ejercicio es:
Modularizar el código creando bloques reutilizables.

En esta lección aprenderemos:
Definición def y llamada de funciones.
Parámetros posicionales y nombrados.
Retorno de valores (return).
Argumentos variables args y kwargs.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Define una función saludar(nombre) que imprima un saludo.
Paso 2: Crea una función sumar(a, b) que devuelva la suma.
Paso 3: Experimenta pasando argumentos por nombre.

Permíteme explicarte más detalles.
Las funciones son bloques de código reutilizables. Nos permiten modularizar nuestros programas y evitar la repetición.

Definimos una función con la palabra clave def. Podemos especificar parámetros, valores por defecto y valores de retorno.

Pasemos al siguiente ejercicio.

Lección: Reto: Los 4 Fantásticos.

El objetivo de este ejercicio es:
Aplicar lógica de conteo y comparación de caracteres en strings.

En esta lección aprenderemos:
Manipulación de strings (upper).
Método .count().
Lógica condicional.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Implementa la función check_is_balanced.
Paso 2: Convierte el texto a mayúsculas.
Paso 3: Cuenta las 'R' y las 'J'.
Paso 4: Retorna True si son iguales o si ambas son 0.

Permíteme explicarte más detalles.
En este reto, deben crear una función que determine si una alianza está equilibrada. Deberán contar las apariciones de ciertos caracteres y comparar sus cantidades. Recuerden normalizar el texto a mayúsculas para facilitar el conteo.

Pasemos al siguiente ejercicio.

Lección: Reto: Jurassic Park.

El objetivo de este ejercicio es:
Filtrar y sumar elementos de una lista basándose en una condición numérica.

En esta lección aprenderemos:
Iteración de listas.
Operador módulo % para paridad.
Acumuladores.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Inicializa una variable suma en 0.
Paso 2: Recorre la lista de huevos.
Paso 3: Si el número es par, súmalo a suma.
Paso 4: Retorna el total.

Permíteme explicarte más detalles.
Aquí deben sumar los "huevos de dinosaurios carnívoros", que están representados por los números pares en una lista. Iteren sobre la lista y utilicen el operador módulo para filtrar los pares.

Pasemos al siguiente ejercicio.

Lección: Reto: Primera Suma.

El objetivo de este ejercicio es:
Encontrar pares de números que cumplan una condición de suma.

En esta lección aprenderemos:
Búsqueda en arrays.
Optimización (fuerza bruta vs. diccionario).
Retorno temprano.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Implementa la función find_first_sum.
Paso 2: Opción A (Fácil): Usa dos bucles for anidados para probar todas las parejas.
Paso 3: Opción B (Eficiente): Usa un diccionario para guardar los números que ya has visto y busca su complemento.

Permíteme explicarte más detalles.
El objetivo es encontrar dos números en un array que sumen un valor objetivo. Pueden usar fuerza bruta con bucles anidados, o una solución más eficiente utilizando un diccionario para recordar los números ya vistos.

Pasemos al siguiente ejercicio.

Lección: Diccionarios.

El objetivo de este ejercicio es:
Almacenar datos estructurados en pares clave-valor.

En esta lección aprenderemos:
Creación y acceso a diccionarios.
Métodos .keys(), .values(), .items().
Modificación y eliminación de claves.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Crea un diccionario que te describa (nombre, edad, hobbies).
Paso 2: Accede a tu edad e imprímela.
Paso 3: Añade una nueva clave 'profesion'.
Paso 4: Itera sobre el diccionario imprimiendo clave y valor.

Permíteme explicarte más detalles.
Los diccionarios son colecciones de pares clave-valor. Son extremadamente útiles para almacenar datos estructurados.

Podemos acceder a los valores mediante sus claves, modificar valores, añadir nuevos pares y eliminar entradas.

Pasemos al siguiente ejercicio.

Lección: Reto: Batalla Pokémon.

El objetivo de este ejercicio es:
Simular una lógica de enfrentamiento comparando listas elemento a elemento.

En esta lección aprenderemos:
Iteración simultánea (o por índice).
Comparación condicional compleja.
Acumulación de resultados.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Implementa la función battle.
Paso 2: Compara cada posición i de ambas listas.
Paso 3: Si A gana, suma la diferencia al siguiente de A.
Paso 4: Si B gana, suma al siguiente de B.
Paso 5: Al final, suma los totales y decide el ganador.

Permíteme explicarte más detalles.
En este reto final del módulo, simularán una batalla comparando elementos de dos listas. Implementen la lógica descrita para determinar el ganador basándose en las diferencias de poder.

.
Módulo 02: Conceptos Fundamentales
.

Pasemos al siguiente ejercicio.

Lección: Hola Mundo (Repaso).

El objetivo de este ejercicio es:
Verificar la configuración del entorno y repasar la ejecución básica.

En esta lección aprenderemos:
Confirmación de entorno Python 3.
Ejecución de scripts.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Verifica que veas el saludo en la consola.

Permíteme explicarte más detalles.
Retomemos nuestro primer programa en Python. Este ejercicio sirve para verificar que nuestro entorno de ejecución está configurado correctamente. Es el primer paso esencial antes de adentrarnos en conceptos más complejos.

Pasemos al siguiente ejercicio.

Lección: Números.

El objetivo de este ejercicio es:
Profundizar en los tipos numéricos y su representación.

En esta lección aprenderemos:
Diferencia entre int y float.
Notación científica (e).
Números complejos (j).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo Python imprime los números grandes y la notación científica.
Paso 3: Intenta crear un número complejo y sumar otro.

Permíteme explicarte más detalles.
En Python, trabajamos principalmente con tres tipos numéricos.

Primero, los enteros o int, que pueden ser positivos, negativos o cero.

Segundo, los números de punto flotante o float, que representan valores decimales. Noten el uso de la notación científica con e para potencias de 10.

Pasemos al siguiente ejercicio.

Lección: Manejo de Errores (Try/Except).

El objetivo de este ejercicio es:
Escribir código resiliente que no se rompa ante errores inesperados.

En esta lección aprenderemos:
Bloques try, except.
Captura de excepciones específicas.
Manejo de códigos de estado HTTP (en el ejemplo).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Cambia la URL a una que no exista para provocar un error.
Paso 3: Observa cómo el bloque except captura el fallo elegantemente.

Permíteme explicarte más detalles.
El manejo de errores es crucial para escribir código robusto. El bloque try-except nos permite capturar excepciones y evitar que nuestro programa se detenga abruptamente.

Pasemos al siguiente ejercicio.

Lección: Comentarios y Docstrings.

El objetivo de este ejercicio es:
Documentar el código para mejorar su legibilidad y mantenimiento.

En esta lección aprenderemos:
Comentarios de línea .
Docstrings """...""" para funciones.
Acceso a documentación con __doc__.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Lee los comentarios en el código.
Paso 2: Añade un comentario explicando qué hace una línea.
Paso 3: Modifica el docstring de la función saludar y ejecútalo.

Permíteme explicarte más detalles.
El código se lee más veces de las que se escribe. Por eso, los comentarios son vitales.

Usamos el símbolo almohadilla para comentarios de una sola línea. Para bloques más extensos, aunque no existen oficialmente, solemos usar cadenas multilínea.

Pasemos al siguiente ejercicio.

Lección: Conversión Numérica.

El objetivo de este ejercicio es:
Practicar la conversión explícita entre tipos numéricos.

En esta lección aprenderemos:
float() a int() (pérdida de precisión).
int() a float().
Conversión a complex().

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa qué pasa con los decimales cuando conviertes un float negativo a int.

Permíteme explicarte más detalles.
A veces necesitamos convertir entre tipos numéricos.

Podemos transformar enteros a flotantes, flotantes a enteros (perdiendo la parte decimal) e incluso números a complejos.

Pasemos al siguiente ejercicio.

Lección: Operaciones Numéricas Extra.

El objetivo de este ejercicio es:
Explorar sistemas numéricos alternativos y precisión decimal.

En esta lección aprenderemos:
Módulo decimal para precisión financiera.
Binario (0b), Octal (0o), Hexadecimal (0x).
Problemas de precisión de punto flotante.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código y sorpréndete con 1.1 + 2.2.
Paso 2: Usa Decimal para corregir esa suma.
Paso 3: Convierte un número decimal a binario con bin().

Permíteme explicarte más detalles.
Profundicemos en los números.

Es importante saber que la aritmética de punto flotante puede tener pequeñas imprecisiones debido a cómo se representan los números en binario. Para precisión exacta, como en finanzas, usamos el módulo decimal.

Pasemos al siguiente ejercicio.

Lección: Cadenas de Texto (Strings).

El objetivo de este ejercicio es:
Manipular texto básico y entender la inmutabilidad de los strings.

En esta lección aprenderemos:
Concatenación.
Longitud len().
Conversión de números a string para concatenar.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Intenta concatenar un número directamente a un string y corrige el error.
Paso 3: Crea un string multilínea con tu dirección.

Permíteme explicarte más detalles.
Las cadenas de texto son secuencias de caracteres. Podemos usar comillas simples, dobles o triples.

La concatenación nos permite unir cadenas con el operador +. Sin embargo, no podemos concatenar directamente un número con una cadena; debemos convertir el número primero.

Pasemos al siguiente ejercicio.

Lección: Formato de Strings.

El objetivo de este ejercicio es:
Presentar datos de forma legible y estructurada.

En esta lección aprenderemos:
Operador % (Legacy).
Método .format().
f-strings (Moderno y recomendado).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta los ejemplos.
Paso 2: Usa f-strings para imprimir "Hola, soy [Nombre] y vivo en [Ciudad]".
Paso 3: Prueba el formateo de decimales con :.2f.

Permíteme explicarte más detalles.
Dar formato a las cadenas es esencial para presentar datos.

Tenemos el operador antiguo %, el método .format() que ofrece gran flexibilidad con argumentos posicionales y nombrados, y las modernas f-strings, que son la forma más recomendada y legible.

Pasemos al siguiente ejercicio.

Lección: Métodos de Strings.

El objetivo de este ejercicio es:
Utilizar métodos integrados para procesar y validar texto.

En esta lección aprenderemos:
Transformación: upper, lower, capitalize.
Validación: isalpha, isnumeric.
Manipulación: split, join, replace.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Convierte tu nombre completo a mayúsculas.
Paso 3: Usa split para separar una frase en palabras.
Paso 4: Valida si un string es un número válido.

Permíteme explicarte más detalles.
La clase str tiene multitud de métodos útiles.

Podemos cambiar mayúsculas y minúsculas con lower, upper y capitalize.

Podemos verificar el contenido con isalnum, isalpha, isnumeric, entre otros.

Pasemos al siguiente ejercicio.

Lección: Estructuras Condicionales.

El objetivo de este ejercicio es:
Tomar decisiones complejas en el código.

En esta lección aprenderemos:
Lógica if-elif-else.
Validación de entradas.
Manejo de casos por defecto (else).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Cambia la variable url a diferentes valores ('http', 'https', vacía).
Paso 2: Observa qué bloque se ejecuta en cada caso.
Paso 3: Añade una nueva condición para detectar dominios '.com'.

Permíteme explicarte más detalles.
Las estructuras de control dirigen el flujo de nuestro programa.

El bloque if-elif-else nos permite tomar decisiones. Recuerden que elif nos permite evaluar múltiples condiciones en secuencia.

Pasemos al siguiente ejercicio.

Lección: Bucle While Avanzado.

El objetivo de este ejercicio es:
Implementar lógica de repetición con condiciones de salida complejas.

En esta lección aprenderemos:
Bucle while con else.
Uso de break para salir prematuramente.
Validación de entrada de usuario.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el simulador de adivinanza.
Paso 2: Descomenta la parte interactiva para jugar tú mismo.
Paso 3: Implementa un límite de intentos.

Permíteme explicarte más detalles.
El bucle while puede ser más complejo. Podemos anidar condiciones dentro de él.

Un patrón común es usar un bucle infinito while True y romperlo con break cuando se cumple una condición deseada.

Pasemos al siguiente ejercicio.

Lección: Bucle For Avanzado.

El objetivo de este ejercicio es:
Iterar sobre estructuras de datos complejas como diccionarios.

En esta lección aprenderemos:
Iteración de claves de diccionario.
Formateo de salida en bucles.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para ver los puertos.
Paso 2: Añade un nuevo puerto al diccionario.
Paso 3: Modifica el bucle para imprimir también el protocolo en mayúsculas.

Permíteme explicarte más detalles.
El bucle for itera sobre secuencias.

Podemos iterar sobre las claves de un diccionario. También podemos usar else con un bucle for.

Pasemos al siguiente ejercicio.

Lección: Uso de Range.

El objetivo de este ejercicio es:
Dominar la generación de secuencias numéricas para iteraciones.

En esta lección aprenderemos:
range con paso positivo y negativo.
Iteración por índice usando range(len(lista)).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta los ejemplos de range.
Paso 2: Crea un bucle que imprima los múltiplos de 5 del 0 al 50.
Paso 3: Itera sobre la lista de puertos usando su índice.

Permíteme explicarte más detalles.
La función range es versátil. Genera secuencias de enteros y es la compañera ideal del bucle for.

Recuerden que range solo acepta enteros. No intenten pasarle flotantes o cadenas.

Pasemos al siguiente ejercicio.

Lección: Control de Bucles (Break/Continue).

El objetivo de este ejercicio es:
Afinar el control sobre la ejecución de los bucles.

En esta lección aprenderemos:
break: Detener el bucle.
continue: Saltar iteración.
pass: Placeholder.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código de escaneo de puertos simulado.
Paso 2: Observa cómo continue salta los puertos web.
Paso 3: Observa cómo break detiene el escaneo al encontrar SSH.

Permíteme explicarte más detalles.
Tenemos control total sobre nuestros bucles.

break termina el bucle inmediatamente.
continue salta el resto de la iteración actual y vuelve al inicio.

Pasemos al siguiente ejercicio.

Lección: Condicionales en Una Línea.

El objetivo de este ejercicio es:
Escribir código más conciso usando expresiones ternarias.

En esta lección aprenderemos:
Sintaxis: valor_si if condicion else valor_no.
Legibilidad vs. Concisión.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta los ejemplos.
Paso 2: Escribe una expresión ternaria que asigne "Par" o "Impar" a una variable según un número.

Permíteme explicarte más detalles.
Para condiciones simples, podemos usar expresiones condicionales en una sola línea. Esto hace el código más conciso, pero úsenlo con moderación para no sacrificar la legibilidad.

Pasemos al siguiente ejercicio.

Lección: Operadores Aritméticos.

El objetivo de este ejercicio es:
Realizar cálculos matemáticos fundamentales.

En esta lección aprenderemos:
Operadores básicos: +, -, , /.
División entera // y Módulo %.
Potencia .

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta las operaciones.
Paso 2: Calcula el resto de dividir 21 entre 5.
Paso 3: Calcula 2 elevado a la 10.

Permíteme explicarte más detalles.
Python soporta todas las operaciones matemáticas estándar: suma, resta, multiplicación y división.

Noten la diferencia entre la división normal /, que devuelve un flotante, y la división entera //, que descarta la parte decimal.

Pasemos al siguiente ejercicio.

Lección: Operadores de Comparación.

El objetivo de este ejercicio es:
Comparar valores para lógica booleana.

En esta lección aprenderemos:
Comparación numérica.
Comparación de strings (orden lexicográfico).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta las comparaciones.
Paso 2: Compara dos strings: "Python" y "Java". ¿Cuál es mayor?
Paso 3: Verifica si 10 es distinto de "10".

Permíteme explicarte más detalles.
Estos operadores comparan dos valores y devuelven un booleano. Funcionan con números y también con cadenas (basándose en el orden alfabético/ASCII).

Pasemos al siguiente ejercicio.

Lección: Operadores de Asignación.

El objetivo de este ejercicio es:
Modificar variables de forma eficiente.

En esta lección aprenderemos:
Asignación simple =.
Asignación compuesta +=, -=, =.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Usa += para incrementar una variable contador.
Paso 3: Usa = para duplicar el valor de una variable.

Permíteme explicarte más detalles.
Más allá del simple =, tenemos operadores de asignación compuesta como +=, -=, =, etc. Estos realizan la operación y actualizan la variable en un solo paso.

Pasemos al siguiente ejercicio.

Lección: Operadores Lógicos.

El objetivo de este ejercicio es:
Combinar condiciones booleanas.

En esta lección aprenderemos:
and: Ambos deben ser ciertos.
or: Al menos uno cierto.
not: Inversión.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta las pruebas lógicas.
Paso 2: Evalúa: True and False or True.
Paso 3: Usa not para invertir una condición.

Permíteme explicarte más detalles.
and, or y not son la base de la lógica booleana en Python. Nos permiten construir condiciones complejas.

Pasemos al siguiente ejercicio.

Lección: Operadores de Identidad.

El objetivo de este ejercicio es:
Entender la diferencia entre igualdad de valor e identidad de objeto.

En esta lección aprenderemos:
is: ¿Son el mismo objeto en memoria?
==: ¿Tienen el mismo valor?
Mutabilidad e identidad.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Crea dos listas idénticas y compáralas con is y ==.
Paso 3: Asigna una lista a otra variable (a = b) y compáralas con is.

Permíteme explicarte más detalles.
Aquí hay una distinción sutil pero importante: == compara valores, mientras que is compara identidad (si son el mismo objeto en memoria).

Pasemos al siguiente ejercicio.

Lección: Estructuras de Datos.

El objetivo de este ejercicio es:
Conocer las estructuras principales para organizar datos.

En esta lección aprenderemos:
Listas []: Ordenadas, mutables.
Tuplas (): Ordenadas, inmutables.
Diccionarios {k:v}: Clave-valor.
Conjuntos {}: Únicos, desordenados.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código de ejemplo.
Paso 2: Crea una lista, una tupla, un set y un diccionario vacíos.
Paso 3: Verifica sus tipos con type().

Permíteme explicarte más detalles.
Las estructuras de datos organizan nuestra información.

Las Listas son ordenadas y mutables.
Las Tuplas son ordenadas e inmutables.
Los Diccionarios son pares clave-valor.
Los Conjuntos (Sets) son colecciones no ordenadas de elementos únicos.

Pasemos al siguiente ejercicio.

Lección: Listas a Fondo.

El objetivo de este ejercicio es:
Manipulación avanzada de listas.

En esta lección aprenderemos:
Slicing complejo.
Métodos de búsqueda y ordenamiento.
Gestión de memoria (copias).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta las operaciones de lista.
Paso 2: Usa slicing para invertir la lista de puertos.
Paso 3: Ordena la lista de puertos de mayor a menor.

Permíteme explicarte más detalles.
Profundicemos en las listas. Podemos verificar existencia con in, acceder por índices positivos o negativos, y usar "slicing" avanzado.

Pasemos al siguiente ejercicio.

Lección: Diccionarios a Fondo.

El objetivo de este ejercicio es:
Modelar datos complejos con diccionarios anidados.

En esta lección aprenderemos:
Estructuras anidadas (JSON-like).
Métodos de acceso seguro .get().
Actualización y fusión de diccionarios.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código de empleados.
Paso 2: Añade un nuevo proyecto al empleado 100.
Paso 3: Usa .get() para acceder a una clave que podría no existir.

Permíteme explicarte más detalles.
Los diccionarios son increíblemente flexibles. Pueden contener listas u otros diccionarios anidados.

Métodos como keys(), values() e items() nos permiten iterar sobre ellos de diferentes formas.

Pasemos al siguiente ejercicio.

Lección: Tuplas.

El objetivo de este ejercicio es:
Trabajar con colecciones inmutables.

En esta lección aprenderemos:
Creación y desempaquetado.
Inmutabilidad (protección de datos).
Conversión lista-tupla.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Crea una tupla con coordenadas GPS.
Paso 2: Intenta modificar un valor y observa el error.
Paso 3: Concatena dos tuplas.

Permíteme explicarte más detalles.
Las tuplas, al ser inmutables, son útiles para datos que no deben cambiar. Pueden contener cualquier tipo de dato. Aunque no podemos modificarlas, podemos concatenarlas o crear nuevas tuplas a partir de ellas.

Pasemos al siguiente ejercicio.

Lección: Conjuntos (Sets).

El objetivo de este ejercicio es:
Manejar colecciones de elementos únicos y operaciones de conjuntos.

En esta lección aprenderemos:
Eliminación de duplicados.
Unión, Intersección, Diferencia.
Pertenencia eficiente.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Crea un set a partir de una lista con duplicados.
Paso 2: Realiza la unión de dos sets.
Paso 3: Encuentra la intersección (elementos comunes).

Permíteme explicarte más detalles.
Los conjuntos son ideales cuando necesitamos unicidad y operaciones matemáticas de conjuntos como unión, intersección y diferencia. No tienen orden, así que no podemos acceder por índice.

Pasemos al siguiente ejercicio.

Lección: Funciones Avanzadas.

El objetivo de este ejercicio es:
Escribir funciones con lógica condicional y retorno.

En esta lección aprenderemos:
Funciones que retornan booleanos.
Ámbito de variables.
Reutilización de código.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Implementa la función es_par.
Paso 2: Llama a la función con diferentes números.
Paso 3: Usa el resultado en un if.

Permíteme explicarte más detalles.
Las funciones son esenciales para la modularidad. Recuerden que pueden devolver valores y que las variables definidas dentro de ellas tienen un ámbito local.

Pasemos al siguiente ejercicio.

Lección: Funciones de Colección.

El objetivo de este ejercicio es:
Aplicar programación funcional para procesar datos.

En esta lección aprenderemos:
lambda: Funciones anónimas.
map: Transformación.
filter: Filtrado.
sorted con clave personalizada.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ordena la lista de personas por edad.
Paso 2: Usa map para crear una lista de solo nombres.
Paso 3: Usa filter para obtener personas mayores de 60 años.

Permíteme explicarte más detalles.
Python ofrece herramientas funcionales como lambda, map y filter.

Las funciones lambda son funciones anónimas pequeñas. map aplica una función a cada elemento de un iterable, y filter selecciona elementos que cumplen una condición.

Pasemos al siguiente ejercicio.

Lección: Funciones Integradas.

El objetivo de este ejercicio es:
Conocer la "caja de herramientas" estándar de Python.

En esta lección aprenderemos:
abs(), bool(), input().
locals() para depuración.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Calcula el valor absoluto de un número negativo.
Paso 2: Usa locals() para ver las variables definidas en el entorno actual.

Permíteme explicarte más detalles.
Python viene con "baterías incluidas". Funciones como abs, bool, input y muchas otras están siempre disponibles sin necesidad de importar nada.

Pasemos al siguiente ejercicio.

Lección: Expresiones Regulares (Regex).

El objetivo de este ejercicio es:
Introducción al reconocimiento de patrones en texto.

En esta lección aprenderemos:
Módulo re.
Patrones básicos.
Validación de formatos (como URLs).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el validador de URLs.
Paso 2: Añade una URL inválida a la lista y ve si la detecta.
Paso 3: Intenta modificar el patrón para aceptar FTP.

Permíteme explicarte más detalles.
Las expresiones regulares son un lenguaje en sí mismo para buscar patrones en texto. Son extremadamente potentes para validaciones y extracción de información.

Pasemos al siguiente ejercicio.

Lección: Introducción a Clases y Objetos.

El objetivo de este ejercicio es:
Comprender los fundamentos de la Programación Orientada a Objetos (POO).

En esta lección aprenderemos:
Clases vs. Objetos.
Atributos y Métodos.
Constructor __init__.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Define una clase simple (ej. Perro).
Paso 2: Crea dos instancias (objetos) de esa clase.
Paso 3: Define un método ladrar y llámalo.

Permíteme explicarte más detalles.
La programación orientada a objetos nos permite modelar el mundo real.

Una clase es una plantilla. Un objeto es una instancia de esa clase.
Los atributos son datos, y los métodos son comportamientos.

.
Módulo 03: Práctica de Algoritmos
.

Pasemos al siguiente ejercicio.

Lección: Clima de la Ciudad.

El objetivo de este ejercicio es:
Simular la obtención y procesamiento de datos complejos (JSON) desde una API externa.

En esta lección aprenderemos:
Estructuras de datos anidadas (JSON).
Conversión de unidades (Kelvin a Celsius).
Manejo de fechas y horas (timestamps).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para ver el reporte del clima simulado.
Paso 2: Modifica el diccionario weather_data cambiando la temperatura o la ciudad.
Paso 3: Observa cómo el script procesa y muestra los nuevos datos.

Permíteme explicarte más detalles.
En el mundo real, interactuamos constantemente con APIs que nos devuelven datos en formato JSON. Este ejercicio simula una respuesta de una API del clima.

Su tarea es comprender cómo extraer información específica de estructuras anidadas, como diccionarios dentro de listas dentro de diccionarios. También realizaremos conversiones prácticas, como pasar de Kelvin a grados Celsius.

Pasemos al siguiente ejercicio.

Lección: Conversor Fahrenheit a Celsius.

El objetivo de este ejercicio es:
Crear una herramienta de conversión con manejo de errores de entrada.

En esta lección aprenderemos:
Definición de funciones matemáticas.
Bloques try-except para validar entradas de usuario.
Fórmulas de conversión.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Cambia el valor de la variable fahr para probar otras temperaturas.
Paso 3: Intenta asignar un texto a fahr para verificar que el manejo de errores funciona.

Permíteme explicarte más detalles.
Vamos a construir una utilidad clásica: un conversor de temperatura.

Más allá de la fórmula matemática, lo interesante aquí es cómo protegemos nuestro programa. Usamos un bloque try-except para asegurarnos de que, si el usuario introduce algo que no es un número, el programa no se rompa y muestre un mensaje amigable.

Pasemos al siguiente ejercicio.

Lección: Base de Datos en Memoria.

El objetivo de este ejercicio es:
Implementar un sistema de almacenamiento clave-valor básico usando Clases.

En esta lección aprenderemos:
Programación Orientada a Objetos (Clases y Métodos).
Manejo de diccionarios como almacenamiento.
Validación de tipos con isinstance.
Lanzamiento de errores personalizados (raise).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para ver cómo se añaden y recuperan empleados.
Paso 2: Intenta añadir un empleado con una clave que no sea un entero (ej. "105") y observa el error.
Paso 3: Implementa un método update en la clase DB.

Permíteme explicarte más detalles.
Aquí empezamos a pensar como ingenieros de software. Vamos a crear una clase DB que simula una base de datos en memoria.

Aprenderán a encapsular la lógica dentro de métodos como set, get y delete. También es crucial validar los datos antes de procesarlos, asegurándonos de que las claves sean del tipo correcto.

Pasemos al siguiente ejercicio.

Lección: DB en Memoria (CMD).

El objetivo de este ejercicio es:
Simular una interfaz de línea de comandos para interactuar con nuestra base de datos.

En esta lección aprenderemos:
Estructura de una aplicación de consola.
Flujo de ejecución principal (main).
Interacción simulada de comandos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo se simulan las operaciones SET, GET y DELETE.
Paso 3: Añade una nueva operación simulada para un empleado ID 106.

Permíteme explicarte más detalles.
Las bases de datos reales a menudo se gestionan mediante comandos. En este ejercicio, extendemos nuestra clase DB para simular un entorno de línea de comandos.

Veremos cómo estructurar un programa con una función main que orquesta las operaciones, simulando la interacción de un usuario que escribe comandos para gestionar registros.

Pasemos al siguiente ejercicio.

Lección: DB en Memoria (JSON).

El objetivo de este ejercicio es:
Añadir persistencia de datos guardando la información en un archivo.

En esta lección aprenderemos:
Persistencia de datos.
Módulo json (load y dump).
Manejo de archivos (open, with).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código. Se creará un archivo db.json.
Paso 2: Abre db.json y verifica su contenido.
Paso 3: Ejecuta el código de nuevo; debería cargar los datos existentes en lugar de empezar de cero.

Permíteme explicarte más detalles.
Hasta ahora, nuestros datos se perdían al cerrar el programa. Ahora introducimos la persistencia.

Usaremos el formato JSON para guardar nuestra base de datos en un archivo en disco. Esto permite que la información sobreviva entre ejecuciones del programa, un concepto fundamental en cualquier aplicación real.

Pasemos al siguiente ejercicio.

Lección: DB Persistente.

El objetivo de este ejercicio es:
Consolidar el concepto de persistencia y operaciones CRUD (Crear, Leer, Actualizar, Borrar).

En esta lección aprenderemos:
Ciclo completo de vida de los datos.
Recuperación de estado.
Manejo robusto de archivos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Modifica el script para que, al iniciar, imprima todos los registros cargados.
Paso 3: Prueba a borrar el archivo db.json manualmente y reinicia el programa.

Permíteme explicarte más detalles.
Este ejercicio es la culminación de nuestro sistema de base de datos. Combinamos la estructura de clases, el manejo de errores y la persistencia en archivos.

El objetivo es que entiendan cómo las aplicaciones modernas guardan y recuperan su estado, permitiendo una continuidad en el uso.

Pasemos al siguiente ejercicio.

Lección: Es Primo.

El objetivo de este ejercicio es:
Implementar un algoritmo matemático clásico para determinar primalidad.

En esta lección aprenderemos:
Lógica algorítmica.
Bucle for con else.
Operador módulo %.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código con el número 29.
Paso 2: Cambia num a 30 y verifica el resultado.
Paso 3: Intenta optimizar el bucle para que solo llegue hasta la raíz cuadrada del número.

Permíteme explicarte más detalles.
Determinar si un número es primo es un problema clásico de algoritmia.

Un número primo solo es divisible por 1 y por sí mismo. Usaremos un bucle para intentar dividir el número por todos los valores menores a él. Si encontramos un divisor, sabemos que no es primo y usamos break para detenernos.

Pasemos al siguiente ejercicio.

Lección: N Números Primos.

El objetivo de este ejercicio es:
Generar una lista de los primeros N números primos.

En esta lección aprenderemos:
Reutilización de funciones.
Bucles while True infinitos controlados.
Listas dinámicas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para generar los primeros 10 primos.
Paso 2: Aumenta nprimes a 50.
Paso 3: Observa cómo el tiempo de ejecución aumenta ligeramente.

Permíteme explicarte más detalles.
Ahora escalaremos nuestro algoritmo. En lugar de verificar un solo número, vamos a generar una lista de los primeros N números primos.

Usaremos un bucle while que no se detendrá hasta que hayamos encontrado la cantidad deseada de primos, reutilizando nuestra lógica de verificación anterior.

Pasemos al siguiente ejercicio.

Lección: Primos en Rango.

El objetivo de este ejercicio es:
Encontrar todos los números primos dentro de un intervalo específico.

En esta lección aprenderemos:
Bucles anidados.
Validación de rangos.
Optimización de búsqueda.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para el rango 10 a 50.
Paso 2: Prueba con un rango más grande, por ejemplo, 100 a 200.
Paso 3: Asegúrate de que el script maneje correctamente si el inicio es mayor que el fin.

Permíteme explicarte más detalles.
En este variante, buscamos primos dentro de un rango definido por el usuario (o variables).

Esto requiere anidar bucles: uno para recorrer los números del rango y otro interno para verificar la primalidad de cada uno. Es un excelente ejercicio para entender la complejidad computacional.

Pasemos al siguiente ejercicio.

Lección: Suma de Dos Índices.

El objetivo de este ejercicio es:
Resolver el problema "Two Sum", un clásico de entrevistas técnicas.

En esta lección aprenderemos:
Uso de diccionarios para búsqueda eficiente O(n).
Algoritmos de optimización.
Manejo de índices y valores.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Cambia el target a otro valor que sea suma de dos números en la lista.
Paso 3: Intenta entender por qué usamos un diccionario (index_dict) en lugar de dos bucles.

Permíteme explicarte más detalles.
Este es un problema famoso: dado un array y un número objetivo, encontrar los índices de los dos números que suman ese objetivo.

La solución ingenua usaría dos bucles, pero aquí aprenderemos una técnica avanzada usando un diccionario para hacerlo en una sola pasada, lo que es mucho más eficiente.

.
Módulo 04: Automatización y Scripts
.

Pasemos al siguiente ejercicio.

Lección: Avatar Básico.

El objetivo de este ejercicio es:
Generar activos gráficos programáticamente usando librerías externas.

En esta lección aprenderemos:
Uso de librerías de terceros (py_avataaars).
Generación de archivos SVG y PNG.
Dependencias del sistema (Cairo).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código en tu entorno local.
Paso 2: Busca los archivos basic_avatar.png y .svg generados.
Paso 3: Si falla, verifica que tengas instaladas las librerías necesarias.

Permíteme explicarte más detalles.
Entramos en el mundo de la automatización creativa. Python tiene un ecosistema gigante de librerías.

En este ejercicio, usamos una librería para generar avatares. Esto demuestra cómo podemos crear contenido visual de forma automática, útil para generar perfiles de usuario por defecto, por ejemplo.

Pasemos al siguiente ejercicio.

Lección: Avatar Personalizado.

El objetivo de este ejercicio es:
Configurar parámetros específicos para personalizar la generación de activos.

En esta lección aprenderemos:
Uso de Enums y constantes de configuración.
Paso de parámetros detallados a constructores.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Modifica los parámetros: cambia hair_color a BLONDE o top_type a otro estilo.
Paso 3: Genera tu propio avatar personalizado.

Permíteme explicarte más detalles.
La personalización es clave. Aquí no solo generamos un avatar genérico, sino que configuramos cada aspecto: color de piel, tipo de ropa, accesorios, etc.

Aprenderán a leer la documentación de una librería para saber qué opciones (Enums) tienen disponibles para configurar sus objetos.

Pasemos al siguiente ejercicio.

Lección: Avatar Personalizado II.

El objetivo de este ejercicio es:
Explorar librerías alternativas y características avanzadas como texto en gráficos.

En esta lección aprenderemos:
Comparación de librerías similares.
Inserción de texto dinámico en imágenes.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Cambia el texto de la camiseta (shirt_text) por tu nombre.
Paso 3: Observa el archivo SVG generado.

Permíteme explicarte más detalles.
A veces existen múltiples herramientas para una misma tarea. Aquí probamos una variante que nos permite poner texto personalizado en la ropa del avatar.

Esto es útil para generar badges o identificaciones personalizadas de forma masiva.

Pasemos al siguiente ejercicio.

Lección: Avatar Aleatorio.

El objetivo de este ejercicio es:
Generar variaciones masivas de contenido de forma aleatoria.

En esta lección aprenderemos:
Métodos estáticos de generación (.random()).
Fijar ciertos atributos mientras se aleatorizan otros.
Generación por lotes.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Se generarán 3 avatares diferentes.
Paso 3: Modifica el código para generar un bucle que cree 10 avatares distintos.

Permíteme explicarte más detalles.
La automatización brilla cuando necesitamos cantidad. Imaginen que necesitan poblar una base de datos de prueba con 1000 usuarios, cada uno con una foto de perfil única.

Con este script, podemos generar infinitas variaciones aleatorias, o variaciones controladas (ej. todos con sombrero pero diferente ropa).

Pasemos al siguiente ejercicio.

Lección: Reloj Digital Básico.

El objetivo de este ejercicio es:
Generar una mini-aplicación web (HTML/JS) desde Python.

En esta lección aprenderemos:
Generación de código fuente (HTML/JS) mediante strings en Python.
Escritura de archivos.
Concepto de "Infraestructura como Código" a pequeña escala.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Abre el archivo reloj_digital.html en tu navegador.
Paso 3: Modifica el código Python para que el reloj tenga fondo blanco y texto negro.

Permíteme explicarte más detalles.
Python no solo sirve para backend. Puede generar el código para el frontend.

En este ejercicio, nuestro script de Python escribe un archivo HTML completo con CSS y JavaScript incrustados. Es un ejemplo básico de cómo un script puede construir otras herramientas o reportes web.

Pasemos al siguiente ejercicio.

Lección: Reloj Digital Avanzado.

El objetivo de este ejercicio es:
Crear un temporizador interactivo inyectando variables de Python en JavaScript.

En esta lección aprenderemos:
Interpolación de variables Python en strings (f-strings).
Lógica de cuenta regresiva en JS generada por Python.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Abre el archivo generado.
Paso 3: Cambia la variable seconds en Python a 60 y regenera el archivo.

Permíteme explicarte más detalles.
Aquí vamos un paso más allá. Usamos Python para configurar la lógica del JavaScript.

La variable seconds se define en Python, pero se inyecta dentro del código JavaScript que escribimos en el archivo HTML. Esto demuestra cómo pasar datos de configuración desde el backend al frontend generado.

Pasemos al siguiente ejercicio.

Lección: Reloj Digital CLI.

El objetivo de este ejercicio es:
Generar un reloj que muestre fecha y hora, practicando el formateo de fechas.

En esta lección aprenderemos:
Objeto Date en JavaScript.
Estilizado CSS para simular displays digitales.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Abre el HTML resultante.
Paso 3: Observa cómo la fecha se formatea dinámicamente.

Permíteme explicarte más detalles.
Continuamos explorando la generación de interfaces. Este reloj incluye la fecha completa.

El aprendizaje clave es la capacidad de Python para orquestar la creación de interfaces de usuario estáticas que tienen comportamiento dinámico gracias al JavaScript inyectado.

Pasemos al siguiente ejercicio.

Lección: Reloj Mundial.

El objetivo de este ejercicio es:
Visualizar datos complejos (zonas horarias) en una interfaz generada.

En esta lección aprenderemos:
Arrays y bucles en JavaScript generados.
Manejo de zonas horarias (Intl.DateTimeFormat).
Diseño Grid en CSS.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Abre el tablero de relojes mundiales.
Paso 3: Añade "Madrid" con zona "Europe/Madrid" a la lista zones en el string de Python.

Permíteme explicarte más detalles.
Este es un ejemplo de un "Dashboard" o tablero de control.

Python define la lista de ciudades y zonas horarias, y genera un HTML que itera sobre esos datos para crear múltiples relojes. Es muy similar a cómo funcionan los motores de plantillas web.

Pasemos al siguiente ejercicio.

Lección: Captura de Cámara (OpenCV  Headless).

El objetivo de este ejercicio es:
Interactuar con hardware (webcam) y procesar imágenes.

En esta lección aprenderemos:
Librería opencv (cv2).
Acceso a dispositivos de hardware.
Captura y guardado de frames.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código (requiere webcam).
Paso 2: Busca el archivo cam_capture.jpg.
Paso 3: Si no tienes cámara, el script manejará el error elegantemente.

Permíteme explicarte más detalles.
Python es excelente para visión por computador. Usamos OpenCV para acceder a la cámara web.

En un entorno de servidor (headless), no podemos abrir ventanas, así que capturamos la imagen y la guardamos directamente en disco. Esto es la base para sistemas de vigilancia o fotomatones automáticos.

Pasemos al siguiente ejercicio.

Lección: Imagen a Caricatura (Real).

El objetivo de este ejercicio es:
Aplicar filtros de procesamiento de imagen para efectos artísticos.

En esta lección aprenderemos:
Librería Pillow (PIL).
Filtros de imagen (CONTOUR, SMOOTH).
Mezcla de imágenes (blend).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo se genera primero un avatar y luego se transforma.
Paso 3: Prueba a cambiar el filtro CONTOUR por FIND_EDGES.

Permíteme explicarte más detalles.
El procesamiento de imágenes es una rama fascinante. Aquí tomamos una imagen existente y le aplicamos filtros para darle un aspecto de "caricatura".

Usamos la librería Pillow, que es el estándar de facto para manipulación de imágenes en Python. Combinamos detección de bordes con suavizado para lograr el efecto.

Pasemos al siguiente ejercicio.

Lección: Caricatura con GUI (Web).

El objetivo de este ejercicio es:
Crear una herramienta interactiva de edición de imágenes basada en web.

En esta lección aprenderemos:
Filtros CSS (grayscale, sepia, blur).
Interacción usuario-interfaz mediante botones.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Abre el editor web generado.
Paso 3: Prueba los diferentes botones para aplicar filtros en tiempo real.

Permíteme explicarte más detalles.
En lugar de procesar la imagen con Python (que es costoso computacionalmente), aquí generamos una interfaz web que usa filtros CSS.

Esto descarga el trabajo al navegador del usuario. Es una lección importante sobre cuándo procesar en el servidor (Python) y cuándo en el cliente (Navegador).

Pasemos al siguiente ejercicio.

Lección: Generador QR (API Real).

El objetivo de este ejercicio es:
Consumir una API pública para generar códigos QR.

En esta lección aprenderemos:
Peticiones HTTP con requests.
Manejo de respuestas binarias (imágenes).
Guardado de streams de datos en archivos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Escanea el código QR generado con tu móvil; debería llevarte a python.org.
Paso 3: Cambia la variable data por tu perfil de LinkedIn y regenera.

Permíteme explicarte más detalles.
No siempre necesitamos reinventar la rueda. Para generar un QR, podemos usar una API existente.

Hacemos una petición GET a un servicio externo, recibimos la imagen en formato binario y la guardamos en nuestro disco. Es un ejemplo perfecto de integración de servicios.

Pasemos al siguiente ejercicio.

Lección: Info de Imagen (PIL).

El objetivo de este ejercicio es:
Extraer metadatos y propiedades técnicas de una imagen.

En esta lección aprenderemos:
Lectura de metadatos (formato, tamaño, modo).
Conversión de modos de color (RGB a Escala de grises).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Asegúrate de tener la imagen qr_code.png del ejercicio anterior.
Paso 2: Ejecuta el código.
Paso 3: Observa la información técnica impresa en consola.

Permíteme explicarte más detalles.
Analizar imágenes es el primer paso para procesarlas. Con Pillow, podemos leer metadatos como el tamaño, el formato (PNG, JPG) y el modo de color.

También realizamos una operación simple: convertir la imagen a escala de grises ("L"), lo cual es útil para pre-procesamiento en IA.

Pasemos al siguiente ejercicio.

Lección: Análisis de Texto (Frecuencia).

El objetivo de este ejercicio es:
Procesar lenguaje natural para extraer estadísticas básicas.

En esta lección aprenderemos:
Limpieza de texto con Regex.
Clase Counter de collections.
Análisis de frecuencia de palabras.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cuáles son las palabras más repetidas.
Paso 3: Pega un texto propio más largo y analiza sus palabras clave.

Permíteme explicarte más detalles.
El Procesamiento de Lenguaje Natural (NLP) comienza aquí. Tomamos un texto "sucio", lo limpiamos quitando puntuación y normalizando a minúsculas.

Luego, usamos Counter para contar eficientemente la frecuencia de cada palabra. Esto es la base para nubes de palabras o análisis de tendencias.

Pasemos al siguiente ejercicio.

Lección: Análisis de Sentimiento (Simple).

El objetivo de este ejercicio es:
Clasificar texto en positivo o negativo mediante un algoritmo basado en reglas.

En esta lección aprenderemos:
Listas de palabras clave (lexicones).
Algoritmo de puntuación simple.
Clasificación condicional.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el analizador.
Paso 2: Añade una frase sarcástica y ve si el algoritmo falla (es muy básico).
Paso 3: Añade más palabras a las listas positivas y negativas.

Permíteme explicarte más detalles.
¿Cómo sabe una máquina si un comentario es bueno o malo?

Implementamos un analizador de sentimientos muy básico basado en "bolsa de palabras". Sumamos puntos por palabras positivas y restamos por negativas. Aunque simple, ilustra el concepto detrás de sistemas más complejos de IA.

Pasemos al siguiente ejercicio.

Lección: Validador de Email (Regex).

El objetivo de este ejercicio es:
Validar formatos de datos complejos usando expresiones regulares robustas.

En esta lección aprenderemos:
Regex avanzada para emails.
Función re.match.
Validación de entradas críticas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el validador.
Paso 2: Prueba con correos extraños pero válidos (ej. user+tag@gmail.com).
Paso 3: Intenta engañar al validador con un correo mal formado.

Permíteme explicarte más detalles.
Validar emails correctamente es difícil. Las expresiones regulares son la herramienta estándar para esto.

Analizaremos un patrón regex que verifica la estructura: usuario, arroba, dominio y extensión. Es vital para formularios de registro y limpieza de bases de datos.

Pasemos al siguiente ejercicio.

Lección: Generador PDF (Reporte).

El objetivo de este ejercicio es:
Crear documentos PDF profesionales de forma programática.

En esta lección aprenderemos:
Librería fpdf2.
Estructura de página, fuentes y celdas.
Generación automática de reportes.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Abre el archivo reporte_simple.pdf.
Paso 3: Intenta añadir una imagen al PDF (busca documentación de fpdf image).

Permíteme explicarte más detalles.
Generar reportes en PDF es una tarea muy común en empresas.

Usamos la librería fpdf2 para crear un documento desde cero, definiendo fuentes, tamaños y añadiendo texto celda por celda. Esto permite automatizar la creación de facturas, informes o diplomas.

Pasemos al siguiente ejercicio.

Lección: Texto a Voz Simple.

El objetivo de este ejercicio es:
Dotar a nuestras aplicaciones de capacidad de habla (TTS).

En esta lección aprenderemos:
Librería pyttsx3.
Configuración de propiedades de voz (velocidad, volumen).
Síntesis de voz offline.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código (asegúrate de tener audio activado).
Paso 2: Experimenta cambiando la velocidad (rate) para que hable más rápido o lento.
Paso 3: Intenta cambiar la voz (índice 0 o 1) si tu sistema tiene varias instaladas.

Permíteme explicarte más detalles.
La accesibilidad es importante. Con pyttsx3, podemos hacer que nuestros scripts "hablen".

Esta librería funciona offline, utilizando los motores de síntesis de voz instalados en tu sistema operativo. Podemos controlar la velocidad, el volumen y la voz utilizada.

Pasemos al siguiente ejercicio.

Lección: Espiral Arcoíris (SVG Turtle).

El objetivo de este ejercicio es:
Crear arte generativo vectorial usando la lógica de "Turtle Graphics".

En esta lección aprenderemos:
Librería svg_turtle.
Bucles y matemáticas para patrones geométricos.
Gráficos vectoriales (SVG).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Abre el SVG generado en un navegador.
Paso 3: Cambia el ángulo de giro levemente (ej. de 59 a 90) para ver un patrón totalmente distinto.

Permíteme explicarte más detalles.
Turtle Graphics es una forma clásica de enseñar programación gráfica.

Aquí usamos una versión que genera archivos SVG. Al mover la "tortuga" y cambiar el color en un bucle, creamos patrones complejos y hermosos con muy pocas líneas de código.

Pasemos al siguiente ejercicio.

Lección: Triángulo de Sierpinski (SVG).

El objetivo de este ejercicio es:
Entender y visualizar la recursividad mediante fractales.

En esta lección aprenderemos:
Recursividad (funciones que se llaman a sí mismas).
Geometría fractal.
División de problemas en sub-problemas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa el triángulo fractal generado.
Paso 3: Aumenta el grado de recursión a 4 o 5 y observa el detalle (y el tiempo de proceso).

Permíteme explicarte más detalles.
Los fractales son estructuras que se repiten a diferentes escalas. El Triángulo de Sierpinski es un ejemplo clásico.

Lo generamos usando recursividad: una función que dibuja un triángulo y luego se llama a sí misma tres veces para dibujar triángulos más pequeños dentro. Es una demostración visual poderosa de la lógica recursiva.

Pasemos al siguiente ejercicio.

Lección: Arte Geométrico (SVG).

El objetivo de este ejercicio es:
Crear patrones complejos mediante la repetición y rotación de formas simples.

En esta lección aprenderemos:
Bucles anidados para gráficos.
Rotación y traslación.
Abstracción de funciones de dibujo (draw_square).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo la rotación de un simple cuadrado crea una forma compleja.
Paso 3: Cambia la función draw_square para dibujar un triángulo y ve qué pasa.

Permíteme explicarte más detalles.
A veces, reglas simples crean resultados complejos.

Aquí definimos una función para dibujar un cuadrado. Luego, en un bucle, dibujamos ese cuadrado, rotamos un poco el lienzo, y repetimos. El resultado es un "spirograph" geométrico fascinante.

Pasemos al siguiente ejercicio.

Lección: Cuadrado y Círculo (SVG).

El objetivo de este ejercicio es:
Dibujar formas básicas y entender la aproximación de curvas.

En esta lección aprenderemos:
Dibujo de polígonos.
Aproximación de círculos mediante polígonos de muchos lados.
Movimiento sin trazo (penup, pendown).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo el círculo está hecho en realidad de pequeñas líneas rectas.
Paso 3: Intenta dibujar un segundo círculo en otra posición.

Permíteme explicarte más detalles.
En gráficos vectoriales básicos, a veces no tenemos una primitiva de "círculo".

Aprendemos a aproximar un círculo dibujando un polígono de muchos lados (ej. 36 lados de 10 grados cada uno). También practicamos mover el cursor sin dibujar (penup) para posicionarnos en el lienzo.

Pasemos al siguiente ejercicio.

Lección: Cuadrado Simple (SVG).

El objetivo de este ejercicio es:
Introducción básica a los comandos de movimiento relativo.

En esta lección aprenderemos:
Comandos forward y right.
Pensamiento secuencial espacial.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Intenta cambiar el color del lápiz a "purple".
Paso 3: Modifica el código para dibujar un rectángulo en lugar de un cuadrado.

Permíteme explicarte más detalles.
Este es el "Hola Mundo" de los gráficos.

Damos instrucciones secuenciales a la tortuga: avanza, gira 90 grados, avanza... Repitiendo esto cuatro veces, cerramos la forma y creamos un cuadrado.

Pasemos al siguiente ejercicio.

Lección: Colores en Terminal (Colorama).

El objetivo de este ejercicio es:
Mejorar la interfaz de usuario en aplicaciones de consola (CLI).

En esta lección aprenderemos:
Librería colorama.
Códigos ANSI para colores (abstraídos).
Estilos de texto (Brillante, Tenue).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código en tu terminal.
Paso 2: Observa los diferentes colores y estilos.
Paso 3: Escribe un mensaje de "¡ERROR FATAL!" en rojo brillante sobre fondo blanco.

Permíteme explicarte más detalles.
Las aplicaciones de consola no tienen por qué ser aburridas o monocromáticas.

colorama nos permite usar colores de forma multiplataforma (funciona en Windows, Linux, Mac). Usamos colores para indicar estado: verde para éxito, rojo para error, amarillo para advertencia.

Pasemos al siguiente ejercicio.

Lección: Descargar Archivos.

El objetivo de este ejercicio es:
Automatizar la descarga de contenido desde internet con barras de progreso.

En esta lección aprenderemos:
Descarga de streams con requests.
Manejo de chunks (fragmentos) de datos.
Visualización de progreso en consola.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script. Descargará el logo de Python.
Paso 2: Pasa una URL de una imagen grande como argumento para ver la barra de progreso en acción.

Permíteme explicarte más detalles.
Descargar archivos grandes requiere cuidado. No queremos cargar todo en memoria de golpe.

Usamos stream=True en la petición y leemos el archivo en "chunks" (trozos). Esto nos permite también calcular y mostrar una barra de progreso, mejorando la experiencia del usuario.

Pasemos al siguiente ejercicio.

Lección: Generar OTP.

El objetivo de este ejercicio es:
Generar códigos de un solo uso (One-Time Passwords) seguros.

En esta lección aprenderemos:
Módulo secrets (criptográficamente seguro) vs random.
Manipulación de strings.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el generador varias veces.
Paso 2: Verifica que los códigos sean siempre diferentes.
Paso 3: Modifica el código para generar un OTP de 8 dígitos.

Permíteme explicarte más detalles.
La seguridad es primordial. Para generar contraseñas o tokens, nunca debemos usar random estándar, ya que es predecible.

Usamos el módulo secrets, diseñado específicamente para criptografía. Generamos una cadena de 6 dígitos numéricos aleatorios, típica de los sistemas de autenticación de dos factores (2FA).

Pasemos al siguiente ejercicio.

Lección: Generador de Contraseñas.

El objetivo de este ejercicio es:
Crear contraseñas robustas y complejas automáticamente.

En esta lección aprenderemos:
Combinación de alfabetos (letras, números, símbolos).
Generación segura de cadenas aleatorias.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el generador.
Paso 2: Cambia la longitud de la contraseña a 16 caracteres.
Paso 3: Modifica el alfabeto para excluir símbolos de puntuación si lo deseas.

Permíteme explicarte más detalles.
Una buena contraseña debe ser larga y variada.

Aquí combinamos letras mayúsculas, minúsculas, números y símbolos. Luego, seleccionamos caracteres aleatorios de este "super alfabeto" usando secrets.choice para construir una contraseña fuerte.

Pasemos al siguiente ejercicio.

Lección: Extraer Links de Web.

El objetivo de este ejercicio es:
Realizar Web Scraping básico para extraer información específica (enlaces).

En esta lección aprenderemos:
Librería BeautifulSoup.
Parsing de HTML.
Filtrado de etiquetas <a> y atributos href.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script contra python.org.
Paso 2: Prueba con otra web, como wikipedia.org.
Paso 3: Observa cómo extrae y lista los enlaces encontrados.

Permíteme explicarte más detalles.
El Web Scraping nos permite convertir la web en una base de datos.

Usamos BeautifulSoup para analizar el HTML de una página. Buscamos todas las etiquetas de anclaje (<a>) y extraemos sus atributos href, permitiéndonos recolectar todos los enlaces de un sitio.

Pasemos al siguiente ejercicio.

Lección: Info Usuario GitHub.

El objetivo de este ejercicio es:
Interactuar con una API REST pública para obtener datos de usuarios.

En esta lección aprenderemos:
Consumo de API REST (GitHub API).
Manejo de cabeceras HTTP (User-Agent).
Procesamiento de respuesta JSON.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script para ver la info del usuario octocat.
Paso 2: Pasa tu propio nombre de usuario de GitHub como argumento.
Paso 3: Observa qué pasa si pones un usuario que no existe.

Permíteme explicarte más detalles.
Las APIs REST son el pegamento de internet. GitHub ofrece una API pública muy completa.

Hacemos una petición GET a la API de usuarios, enviando las cabeceras adecuadas. La respuesta JSON contiene toda la información pública del perfil, que luego formateamos y mostramos.

Pasemos al siguiente ejercicio.

Lección: Convertir HEIC a PNG.

El objetivo de este ejercicio es:
Automatizar la conversión de formatos de archivo de imagen modernos.

En esta lección aprenderemos:
Formato HEIC (iPhone).
Librería pillow-heif.
Automatización de tareas de sistema de archivos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Si tienes una foto de iPhone (.heic), úsala. Si no, el script crea un dummy.
Paso 2: Ejecuta el script.
Paso 3: Verifica que se haya creado la versión .png de la imagen.

Permíteme explicarte más detalles.
El formato HEIC es eficiente pero no universalmente compatible.

Creamos un script que detecta archivos HEIC y los convierte automáticamente a PNG, un formato más estándar. Esto es ideal para procesar lotes de fotos subidas por usuarios desde dispositivos móviles.

Pasemos al siguiente ejercicio.

Lección: Rangos IP (JSON).

El objetivo de este ejercicio es:
Analizar archivos de datos de infraestructura (rangos IP de AWS).

En esta lección aprenderemos:
Lectura de estructuras JSON complejas.
Filtrado de datos (regiones, servicios).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa la estructura del JSON impreso.
Paso 3: Intenta escribir un código que filtre solo las IPs de la región "ap-northeast-2".

Permíteme explicarte más detalles.
Los proveedores de nube como AWS publican sus rangos de IP en formato JSON.

Saber leer y filtrar estos archivos es útil para configurar firewalls o listas de acceso de seguridad, permitiendo tráfico solo desde regiones o servicios específicos.

Pasemos al siguiente ejercicio.

Lección: Scraping con Selenium.

El objetivo de este ejercicio es:
Automatizar un navegador real para extraer datos de webs dinámicas.

En esta lección aprenderemos:
Librería Selenium.
Control de navegador (Chrome) en modo Headless.
Selección de elementos por CSS Selector.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el scraper. (Requiere Chrome instalado).
Paso 2: Observa cómo navega (invisiblemente) y extrae títulos de libros.
Paso 3: Modifica el selector CSS para extraer los precios en lugar de los títulos.

Permíteme explicarte más detalles.
Cuando las webs usan mucho JavaScript, requests no es suficiente. Necesitamos un navegador real.

Selenium nos permite controlar Chrome mediante código. Podemos navegar, hacer clic y extraer datos tal como lo haría un humano, pero a velocidad de máquina.

Pasemos al siguiente ejercicio.

Lección: Análisis de Datos CSV.

El objetivo de este ejercicio es:
Procesar hojas de cálculo y datos tabulares.

En esta lección aprenderemos:
Formato CSV.
Librería csv (DictReader, writer).
Cálculos agregados sobre filas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Observa cómo crea un archivo, lo lee y calcula totales.
Paso 3: Modifica el script para calcular el promedio de precios.

Permíteme explicarte más detalles.
CSV es el formato universal para intercambio de datos tabulares.

Python tiene una librería nativa excelente para esto. Usamos DictReader para leer cada fila como un diccionario, lo que hace el código muy legible al acceder a las columnas por su nombre.

Pasemos al siguiente ejercicio.

Lección: Manipulación de PDF.

El objetivo de este ejercicio es:
Leer, extraer texto y modificar archivos PDF.

En esta lección aprenderemos:
Librería pypdf.
Extracción de texto.
División y creación de PDFs (splitting).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Verifica que se cree demo.pdf y luego su copia.
Paso 3: Lee el texto extraído en la consola.

Permíteme explicarte más detalles.
Los PDFs son documentos complejos, no texto plano.

Con pypdf, podemos navegar por la estructura interna del PDF. En este ejercicio, extraemos el texto de una página y luego creamos un nuevo archivo PDF que contiene solo esa página extraída.

Pasemos al siguiente ejercicio.

Lección: PDF a Imágenes.

El objetivo de este ejercicio es:
Renderizar páginas de un documento PDF como imágenes rasterizadas.

En esta lección aprenderemos:
Librería pdf2image.
Dependencia externa (Poppler).
Conversión de formatos de documento a imagen.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código (requiere Poppler).
Paso 2: Revisa las imágenes JPG generadas para cada página del PDF.
Paso 3: Esto es útil para generar previsualizaciones de documentos.

Permíteme explicarte más detalles.
A veces necesitamos mostrar un PDF en una web como imagen, o procesarlo con visión artificial.

Esta herramienta convierte cada página del documento en una imagen JPG independiente, permitiéndonos manipularla como cualquier otra foto.

Pasemos al siguiente ejercicio.

Lección: Validador Regex.

El objetivo de este ejercicio es:
Crear funciones de validación reutilizables con expresiones regulares.

En esta lección aprenderemos:
Patrones para teléfonos y usuarios.
Encapsulamiento en funciones.
Pruebas de validación.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta las validaciones.
Paso 2: Modifica el patrón de usuario para que acepte guiones medios -.
Paso 3: Prueba con un número de teléfono que tenga espacios en lugar de guiones.

Permíteme explicarte más detalles.
Las expresiones regulares son la navaja suiza de la validación.

Aquí definimos patrones estrictos para números de teléfono y nombres de usuario. Encapsular estas validaciones en funciones hace que nuestro código sea modular y fácil de probar.

Pasemos al siguiente ejercicio.

Lección: Renombrar Archivos Masivamente.

El objetivo de este ejercicio es:
Automatizar tareas tediosas de gestión de archivos.

En esta lección aprenderemos:
Módulo os y shutil.
Manipulación de rutas y nombres de archivo.
Operaciones en lote (batch).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script. Verás que crea archivos "sucios" y los limpia.
Paso 2: Observa cómo elimina los números y guiones del principio.
Paso 3: Modifica la lógica para reemplazar espacios por guiones bajos.

Permíteme explicarte más detalles.
¿Alguna vez has tenido que renombrar 100 fotos a mano? Nunca más.

Este script itera sobre una carpeta, aplica una lógica de transformación al nombre de cada archivo (limpiando caracteres no deseados) y los renombra automáticamente. Es la esencia de la automatización con Python.

Pasemos al siguiente ejercicio.

Lección: Información del Sistema.

El objetivo de este ejercicio es:
Obtener datos del entorno de ejecución y hardware.

En esta lección aprenderemos:
Módulo platform y sys.
Información del SO, procesador y arquitectura.
Diagnóstico de entorno.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Observa la información detallada sobre tu máquina.
Paso 3: Es útil para scripts que deben comportarse distinto según el SO (Windows vs Linux).

Permíteme explicarte más detalles.
Para scripts de administración de sistemas, necesitamos conocer el entorno.

Python nos da acceso a detalles de bajo nivel: qué sistema operativo es, qué versión de kernel, qué procesador tiene, etc. Esto es vital para diagnósticos y compatibilidad.

Pasemos al siguiente ejercicio.

Lección: Recordatorio de Descanso.

El objetivo de este ejercicio es:
Crear una utilidad de bienestar que interactúa con el navegador.

En esta lección aprenderemos:
Módulo time (sleep).
Módulo webbrowser.
Automatización de escritorio simple.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script y espera 3 segundos.
Paso 2: Observa cómo se abre tu navegador automáticamente.
Paso 3: Cambia la URL a tu video musical favorito.

Permíteme explicarte más detalles.
Los scripts también pueden cuidar de nosotros.

Este ejemplo simple usa time.sleep para pausar la ejecución (simulando un temporizador de trabajo) y luego webbrowser para abrir una acción, recordándonos tomar un descanso.

Pasemos al siguiente ejercicio.

Lección: Validador de Contraseñas.

El objetivo de este ejercicio es:
Implementar políticas de seguridad complejas para contraseñas.

En esta lección aprenderemos:
Regex "Lookahead" (?=).
Validación de múltiples criterios simultáneos.
Seguridad de contraseñas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el validador contra la lista de contraseñas.
Paso 2: Analiza por qué algunas fallan y otras pasan.
Paso 3: Crea una contraseña que cumpla todos los requisitos y pruébala.

Permíteme explicarte más detalles.
Validar una contraseña segura requiere verificar muchas cosas a la vez: longitud, mayúsculas, números, símbolos.

Usamos una expresión regular avanzada con "lookaheads" positivos. Esto nos permite verificar todas estas condiciones en una sola expresión potente y compacta.

Pasemos al siguiente ejercicio.

Lección: Duración de Video.

El objetivo de este ejercicio es:
Extraer metadatos multimedia (video).

En esta lección aprenderemos:
Librería moviepy.
Análisis de archivos de video.
Extracción de duración y resolución.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Si tienes un video .mp4, úsalo. Si no, el script te avisará.
Paso 2: Ejecuta el análisis.
Paso 3: Observa la duración exacta y la resolución del video.

Permíteme explicarte más detalles.
El análisis multimedia es otra gran área de Python.

Con moviepy, podemos abrir archivos de video y extraer sus propiedades técnicas sin necesidad de reproducirlos. Esto es útil para organizar bibliotecas de medios o validar subidas de usuarios.

.
Módulo 05: Ciberseguridad y Criptografía
.

Pasemos al siguiente ejercicio.

Lección: Criptografía Básica.

El objetivo de este ejercicio es:
Implementar cifrado simétrico para proteger mensajes confidenciales.

En esta lección aprenderemos:
Cifrado simétrico con Fernet.
Generación y gestión de claves.
Concepto de encriptar y desencriptar.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Cambia el mensaje secreto por uno propio.
Paso 3: Intenta desencriptar el mensaje usando una clave diferente (generada con Fernet.generate_key()) y observa el error.

Permíteme explicarte más detalles.
La criptografía es la base de la seguridad digital. Aquí usamos Fernet, una implementación de cifrado simétrico.

Simétrico significa que usamos la misma clave para cerrar (encriptar) y abrir (desencriptar) el mensaje. Si pierdes la clave, pierdes el mensaje. Si alguien roba la clave, puede leer tus secretos.

Pasemos al siguiente ejercicio.

Lección: Hashing de Contraseñas.

El objetivo de este ejercicio es:
Entender cómo almacenar contraseñas de forma segura usando funciones hash.

En esta lección aprenderemos:
Diferencia entre cifrado (reversible) y hash (irreversible).
Algoritmos MD5 (obsoleto) vs SHA-256.
Importancia del "Salt" para evitar ataques de Rainbow Tables.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código.
Paso 2: Observa cómo el mismo texto siempre genera el mismo hash.
Paso 3: Cambia un solo carácter de la contraseña y ve cómo el hash cambia totalmente.

Permíteme explicarte más detalles.
Nunca debemos guardar contraseñas en texto plano. Usamos funciones hash, que son unidireccionales: puedes convertir una contraseña en hash, pero no al revés.

También introducimos el concepto de "Salt": añadir datos aleatorios a la contraseña antes de hashearla para hacerla única y resistente a ataques precalculados.

Pasemos al siguiente ejercicio.

Lección: Cracking de Contraseñas (Hash).

El objetivo de este ejercicio es:
Simular un ataque de fuerza bruta para entender la debilidad de contraseñas simples.

En esta lección aprenderemos:
Mecánica de un ataque de fuerza bruta.
Comparación de hashes.
Coste computacional de contraseñas débiles.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script. Intentará adivinar un PIN de 4 dígitos.
Paso 2: Cambia el TARGET_HASH por el hash de "9999" (genéralo en el ejercicio anterior).
Paso 3: Reflexiona sobre cuánto tardaría si fuera una contraseña de 8 letras.

Permíteme explicarte más detalles.
Para entender cómo defenderse, hay que pensar como un atacante.

En este ejercicio, simulamos ser un hacker que ha robado una base de datos de hashes. Usamos un script para probar todas las combinaciones posibles de PINs (0000-9999) hasta encontrar la que coincide con el hash robado.

Pasemos al siguiente ejercicio.

Lección: Inyección SQL (Demo SQLite).

El objetivo de este ejercicio es:
Demostrar la vulnerabilidad web más crítica y cómo funciona.

En esta lección aprenderemos:
Funcionamiento de SQL Injection.
Peligro de concatenar strings en consultas SQL.
Manipulación de lógica booleana (OR '1'='1').

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el código para ver el login normal y el fallido.
Paso 2: Observa el tercer caso: el ataque.
Paso 3: Intenta modificar el ataque para borrar la tabla (DROP TABLE users) - ¡Cuidado, es destructivo!

Permíteme explicarte más detalles.
La inyección SQL ocurre cuando un atacante logra que la base de datos ejecute código malicioso.

Esto sucede a menudo por concatenar texto del usuario directamente en la consulta. Veremos cómo un simple ' OR '1'='1 puede engañar al sistema para que nos deje entrar sin contraseña.

Pasemos al siguiente ejercicio.

Lección: Detector de Phishing (URL).

El objetivo de este ejercicio es:
Analizar URLs sospechosas mediante heurística básica.

En esta lección aprenderemos:
Análisis de cadenas para seguridad.
Patrones comunes de phishing (IPs, longitud, arrobas).
Puntuación de riesgo (Scoring).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el detector con las URLs de ejemplo.
Paso 2: Añade una URL legítima (ej. tu banco) y ve si da falsos positivos.
Paso 3: Añade una URL claramente maliciosa inventada y verifica si la detecta.

Permíteme explicarte más detalles.
El phishing engaña al usuario para que revele sus datos. Las URLs suelen tener características delatoras.

Creamos un script que busca "banderas rojas": uso de direcciones IP en lugar de dominios, URLs excesivamente largas, o el uso del símbolo @ para confundir al navegador.

Pasemos al siguiente ejercicio.

Lección: Info de Cabeceras HTTP.

El objetivo de este ejercicio es:
Inspeccionar el tráfico web invisible (cabeceras) para reconocimiento.

En esta lección aprenderemos:
Estructura del protocolo HTTP.
Cabeceras de petición vs respuesta.
Información revelada por el servidor (Server, X-Powered-By).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script contra un sitio web.
Paso 2: Analiza qué servidor web están usando (Apache, Nginx, etc.).
Paso 3: Busca cabeceras que revelen versiones de software.

Permíteme explicarte más detalles.
Cada vez que visitas una web, hay una conversación oculta de "cabeceras" entre tu navegador y el servidor.

Para un experto en ciberseguridad, estas cabeceras son oro. Revelan qué software corre el servidor, versiones y configuraciones, lo cual es el primer paso para buscar vulnerabilidades específicas.

Pasemos al siguiente ejercicio.

Lección: Cabeceras de Seguridad.

El objetivo de este ejercicio es:
Auditar la seguridad de un sitio web verificando sus cabeceras de protección.

En esta lección aprenderemos:
Cabeceras de seguridad modernas (HSTS, CSP, X-Frame-Options).
Importancia de User-Agent.
Auditoría de seguridad web.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script contra google.com (suelen tener buena seguridad).
Paso 2: Ejecuta contra un sitio web personal o antiguo.
Paso 3: Compara qué cabeceras faltan en el sitio menos seguro.

Permíteme explicarte más detalles.
Los navegadores modernos tienen mecanismos de defensa potentes, pero el servidor debe activarlos.

Este script actúa como un auditor de seguridad, verificando si el sitio web está enviando las instrucciones correctas para proteger a sus usuarios contra ataques como XSS o Clickjacking.

Pasemos al siguiente ejercicio.

Lección: Escáner de Puertos (Socket).

El objetivo de este ejercicio es:
Crear una herramienta de reconocimiento de red básica.

En esta lección aprenderemos:
Sockets de red.
Conexiones TCP.
Estados de puertos (Abierto/Cerrado).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el escáner contra localhost (127.0.0.1).
Paso 2: Si tienes un servidor web corriendo, deberías ver el puerto 80 abierto.
Paso 3: Añade el puerto 3306 (MySQL) a la lista de escaneo.

Permíteme explicarte más detalles.
Saber qué "puertas" (puertos) tiene abiertas un ordenador es vital.

Usamos sockets para intentar conectar a una lista de puertos comunes. Si la conexión se acepta, el puerto está abierto. Es una versión simplificada de herramientas profesionales como Nmap.

Pasemos al siguiente ejercicio.

.
Módulo 06: Proyectos Finales
.

Pasemos al siguiente ejercicio.

Lección: Proyecto 1: Web Scraper (Petición).

El objetivo de este ejercicio es:
Iniciar un proyecto de extracción de datos real obteniendo el HTML crudo.

En esta lección aprenderemos:
Flujo de trabajo de Scraping: Petición -> Guardado -> Análisis.
Manejo de codificación (utf-8).
Inspección preliminar de datos.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Verifica que se ha descargado el archivo books.html.
Paso 3: Abre ese archivo en tu navegador para ver qué descargaste.

Permíteme explicarte más detalles.
Este es el primer paso de nuestro proyecto final de Scraping.

Antes de analizar nada, necesitamos obtener la materia prima. Hacemos una petición a una librería online de prueba y guardamos el código HTML en nuestro disco. Esto nos permite trabajar offline y no saturar el servidor con peticiones repetidas.

Pasemos al siguiente ejercicio.

Lección: Proyecto 1: Web Scraper (Extracción).

El objetivo de este ejercicio es:
Procesar el HTML guardado para extraer datos estructurados y exportarlos.

En esta lección aprenderemos:
Parsing avanzado con BeautifulSoup.
Estrategias de localización de elementos (clases, etiquetas anidadas).
Exportación a CSV.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Asegúrate de tener books.html del paso anterior.
Paso 2: Ejecuta el script.
Paso 3: Abre libros_extraidos.csv en Excel o LibreOffice para ver tu base de datos de libros.

Permíteme explicarte más detalles.
Ahora convertimos el caos del HTML en orden.

Usamos BeautifulSoup para "bucear" en la estructura de la página. Buscamos cada libro, extraemos su título, precio y disponibilidad, y finalmente lo guardamos todo en un archivo CSV limpio y ordenado.

Pasemos al siguiente ejercicio.

Lección: Proyecto 2: Analizador de Logs (Lectura).

El objetivo de este ejercicio es:
Simular y leer archivos de registro (logs) de servidores.

En esta lección aprenderemos:
Formatos de log estándar (Apache/Nginx).
Generación de datos de prueba.
Lectura secuencial de archivos grandes.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script para generar el archivo server.log.
Paso 2: Observa el formato de cada línea.
Paso 3: Modifica el generador para añadir una línea con una IP sospechosa.

Permíteme explicarte más detalles.
Los administradores de sistemas viven pegados a los logs.

En este proyecto, primero generamos un archivo de logs simulado que imita el formato estándar de un servidor web. Luego, escribimos un script para leerlo línea por línea, preparándonos para el análisis.

Pasemos al siguiente ejercicio.

Lección: Proyecto 2: Analizador de Logs (Reporte).

El objetivo de este ejercicio es:
Extraer inteligencia y estadísticas de los logs del servidor.

En esta lección aprenderemos:
Regex para parsing de logs.
Análisis estadístico con Counter.
Detección de anomalías (errores 404, IPs frecuentes).

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script sobre el server.log generado.
Paso 2: Revisa el reporte en consola y el archivo de texto generado.
Paso 3: Identifica cuál es la IP que más peticiones ha hecho.

Permíteme explicarte más detalles.
Los datos crudos no sirven de mucho; necesitamos información.

Usamos expresiones regulares para "despedazar" cada línea del log y extraer la IP y el código de estado. Luego, calculamos estadísticas vitales: ¿Cuántos errores hubo? ¿Quién nos visita más? Esto es esencial para detectar ataques o problemas de rendimiento.

Pasemos al siguiente ejercicio.

Lección: Proyecto 3: Organizador de Archivos.

El objetivo de este ejercicio es:
Crear un script de automatización que ordene una carpeta caótica.

En esta lección aprenderemos:
Gestión del sistema de archivos (os, shutil).
Lógica de clasificación por extensión.
Creación dinámica de carpetas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script.
Paso 2: Observa cómo crea una carpeta downloads_test llena de archivos mezclados.
Paso 3: Ve cómo mágicamente los mueve a carpetas Imagenes, Documentos, etc.

Permíteme explicarte más detalles.
Todos tenemos una carpeta de "Descargas" desordenada.

Este script es una herramienta práctica para la vida real. Analiza la extensión de cada archivo y lo mueve a su carpeta correspondiente. Es un ejemplo perfecto de cómo Python puede automatizar tareas tediosas del día a día.

Pasemos al siguiente ejercicio.

Lección: Proyecto Final: Escáner de Red Avanzado (Nmap-like).

El objetivo de este ejercicio es:
Desarrollar una herramienta de escaneo de red robusta y continua, similar a Nmap.

En esta lección aprenderemos:
Escaneo de múltiples puertos en bucle.
Manejo de timeouts y errores de conexión.
Creación de menús interactivos en consola.
Validación de rangos de direcciones IP.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: Ejecuta el script y selecciona la opción de escaneo rápido.
Paso 2: Introduce la IP de tu máquina local (localhost) o una de tu red.
Paso 3: Observa cómo la herramienta descubre los puertos abiertos en tiempo real.

Permíteme explicarte más detalles.
Este es el desafío final de ciberseguridad. Vamos a combinar todo lo aprendido: sockets, bucles, control de flujo y manejo de errores.

A diferencia del escáner simple anterior, esta herramienta está diseñada para ser persistente y robusta. Implementaremos un menú principal que permita realizar múltiples escaneos sin cerrar el programa, y mejoraremos la detección de puertos para evitar falsos negativos. Es una herramienta que podrías usar en una auditoría real básica.

Pasemos al siguiente ejercicio.

.
Módulo 07: Certificación
.

Pasemos al siguiente ejercicio.

Lección: Obtener Certificado.

El objetivo de este ejercicio es:
Generar un diploma personalizado en PDF como recompensa final.

En esta lección aprenderemos:
Uso avanzado de fpdf2.
Posicionamiento absoluto y alineación.
Inserción de fechas dinámicas.

Para realizar el ejercicio, sigue estas instrucciones:
Paso 1: IMPORTANTE: Edita el código y pon TU NOMBRE en la variable nombre_estudiante.
Paso 2: Ejecuta el script.
Paso 3: ¡Disfruta de tu certificado de finalización! Te lo has ganado.

Permíteme explicarte más detalles.
¡Felicidades! Han llegado al final del curso.

Como último ejercicio, usarán todo lo aprendido para generar su propio certificado de finalización. Este script crea un PDF con diseño profesional, inserta su nombre y la fecha actual. Es un recuerdo tangible de su esfuerzo y aprendizaje.