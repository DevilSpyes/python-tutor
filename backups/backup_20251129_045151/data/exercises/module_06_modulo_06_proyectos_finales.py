from data.exercises import Module, Lesson

MODULE = Module(
    id=6,
    title="Módulo 06: Proyectos Finales",
    lessons=[
        Lesson(
            id=110,
            title="Proyecto 1: Web Scraper (Petición)",
            content='Estudia el siguiente código: Proyecto 1: Web Scraper (Petición)',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# Proyecto Final 1: Web Scraper de Libros\n# Parte 1: Realizar la petición HTTP\n\nimport requests\n\n# Sitio de pruebas para scraping\nURL = "http://books.toscrape.com/"\n\nprint(f"Conectando a {URL}...")\n\ntry:\n    response = requests.get(URL)\n    \n    if response.status_code == 200:\n        print("¡Conexión exitosa!")\n        print(f"Status Code: {response.status_code}")\n        print(f"Encoding: {response.encoding}")\n        \n        # Mostrar los primeros 500 caracteres del HTML\n        html_content = response.text\n        print("\\n--- Contenido HTML (Fragmento) ---")\n        print(html_content[:500])\n        print("...")\n        \n        # Guardamos el HTML para la siguiente parte\n        with open("books.html", "w", encoding="utf-8") as f:\n            f.write(html_content)\n        print("\\nHTML guardado en \'books.html\'")\n        \n    else:\n        print(f"Error: Status Code {response.status_code}")\n        \nexcept Exception as e:\n    print(f"Error de conexión: {e}")\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código en tu IDE local.\n# 2. Verifica que se haya creado el archivo \'books.html\'.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),
        Lesson(
            id=111,
            title="Proyecto 1: Web Scraper (Extracción)",
            content='Estudia el siguiente código: Proyecto 1: Web Scraper (Extracción)',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# Proyecto Final 1: Web Scraper de Libros\n# Parte 2: Extraer datos con BeautifulSoup\n\nfrom bs4 import BeautifulSoup\nimport os\nimport csv\n\nfilename = "books.html"\n\nif not os.path.exists(filename):\n    print(f"Error: {filename} no existe. Ejecuta la lección anterior.")\nelse:\n    print(f"Analizando {filename}...")\n    with open(filename, "r", encoding="utf-8") as f:\n        html_content = f.read()\n        \n    soup = BeautifulSoup(html_content, "html.parser")\n    \n    # Encontrar todos los artículos de libros\n    articles = soup.find_all("article", class_="product_pod")\n    print(f"Se encontraron {len(articles)} libros.\\n")\n    \n    books_data = []\n    \n    for article in articles:\n        # Título (está en el atributo title del enlace h3 -> a)\n        h3 = article.find("h3")\n        link = h3.find("a")\n        title = link["title"]\n        \n        # Precio (está en div class="product_price" -> p class="price_color")\n        price_tag = article.find("p", class_="price_color")\n        price = price_tag.text\n        \n        # Disponibilidad\n        stock_tag = article.find("p", class_="instock availability")\n        stock = stock_tag.text.strip()\n        \n        print(f"Libro: {title[:30]}... | Precio: {price}")\n        books_data.append([title, price, stock])\n        \n    # Guardar a CSV\n    csv_file = "libros_extraidos.csv"\n    with open(csv_file, "w", newline="", encoding="utf-8") as f:\n        writer = csv.writer(f)\n        writer.writerow(["Titulo", "Precio", "Stock"])\n        writer.writerows(books_data)\n        \n    print(f"\\nDatos exportados a {csv_file}")\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código en tu IDE local.\n# 2. Abre el archivo CSV generado (o léelo con Python) para ver los resultados.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),
        Lesson(
            id=112,
            title="Proyecto 2: Analizador de Logs (Lectura)",
            content='Estudia el siguiente código: Proyecto 2: Analizador de Logs (Lectura)',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# Proyecto Final 2: Analizador de Logs de Servidor\n# Parte 1: Generar y Leer Logs\n\n# Simulamos un archivo de logs de Apache/Nginx\nlog_data = """\n192.168.1.10 - - [23/Nov/2025:10:00:01 +0000] "GET /index.html HTTP/1.1" 200 1024\n192.168.1.11 - - [23/Nov/2025:10:00:05 +0000] "GET /about.html HTTP/1.1" 200 512\n192.168.1.12 - - [23/Nov/2025:10:00:10 +0000] "GET /contact.php HTTP/1.1" 404 150\n192.168.1.10 - - [23/Nov/2025:10:00:15 +0000] "POST /login HTTP/1.1" 200 0\n10.0.0.5 - - [23/Nov/2025:10:01:00 +0000] "GET /admin HTTP/1.1" 403 200\n192.168.1.11 - - [23/Nov/2025:10:01:05 +0000] "GET /style.css HTTP/1.1" 200 3000\n"""\n\nfilename = "server.log"\nprint(f"Creando archivo de logs simulado: {filename}")\nwith open(filename, "w") as f:\n    f.write(log_data.strip())\n\nprint("Leyendo archivo línea por línea...")\nwith open(filename, "r") as f:\n    for i, line in enumerate(f, 1):\n        print(f"Línea {i}: {line.strip()}")\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código en tu IDE local.\n# 2. Añade manualmente una línea más al archivo log_data con un error 500.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),
        Lesson(
            id=113,
            title="Proyecto 2: Analizador de Logs (Reporte)",
            content='Estudia el siguiente código: Proyecto 2: Analizador de Logs (Reporte)',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# Proyecto Final 2: Analizador de Logs de Servidor\n# Parte 2: Generar Reporte de Estadísticas\n\nimport re\nfrom collections import Counter\n\nfilename = "server.log"\n\nprint("Analizando logs...")\n\nip_pattern = r"(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})"\nstatus_pattern = r"\\" (\\d{3}) "\n\nips = []\nstatus_codes = []\n\ntry:\n    with open(filename, "r") as f:\n        for line in f:\n            # Extraer IP\n            ip_match = re.search(ip_pattern, line)\n            if ip_match:\n                ips.append(ip_match.group(1))\n            \n            # Extraer Código de Estado\n            status_match = re.search(status_pattern, line)\n            if status_match:\n                status_codes.append(status_match.group(1))\n                \n    # Estadísticas\n    total_requests = len(ips)\n    unique_ips = len(set(ips))\n    top_ips = Counter(ips).most_common(3)\n    errors_404 = status_codes.count("404")\n    errors_403 = status_codes.count("403")\n    \n    print(f"\\n--- Reporte de Tráfico ---")\n    print(f"Total Peticiones: {total_requests}")\n    print(f"IPs Únicas: {unique_ips}")\n    print(f"Errores 404: {errors_404}")\n    print(f"Errores 403: {errors_403}")\n    print(f"\\nTop 3 IPs Activas:")\n    for ip, count in top_ips:\n        print(f"  {ip}: {count} peticiones")\n        \n    # Guardar reporte\n    with open("reporte_logs.txt", "w") as f:\n        f.write(f"Reporte generado.\\nTotal: {total_requests}\\nErrores 404: {errors_404}")\n    print("\\nReporte guardado en \'reporte_logs.txt\'")\n        \nexcept FileNotFoundError:\n    print("Error: server.log no encontrado.")\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código en tu IDE local.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),
        Lesson(
            id=114,
            title="Proyecto 3: Organizador de Archivos",
            content='Estudia el siguiente código: Proyecto 3: Organizador de Archivos',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# Proyecto Final 3: Organizador Automático de Archivos\n\nimport os\nimport shutil\n\n# 1. Configuración: Crear entorno de prueba\nbase_dir = "downloads_test"\nif not os.path.exists(base_dir):\n    os.mkdir(base_dir)\n    \n# Crear archivos dummy\nfiles_to_create = ["foto1.jpg", "documento.pdf", "notas.txt", "cancion.mp3", "foto2.png", "script.py"]\nprint(f"Creando archivos de prueba en {base_dir}...")\nfor f in files_to_create:\n    with open(os.path.join(base_dir, f), "w") as file:\n        file.write("dummy content")\n\n# 2. Lógica de Organización\ndef organizar_archivos(directorio):\n    extensions = {\n        "Imagenes": [".jpg", ".png", ".gif"],\n        "Documentos": [".pdf", ".txt", ".docx"],\n        "Audio": [".mp3", ".wav"],\n        "Codigo": [".py", ".js", ".html"]\n    }\n    \n    print(f"\\nOrganizando {directorio}...")\n    \n    for filename in os.listdir(directorio):\n        filepath = os.path.join(directorio, filename)\n        \n        if os.path.isdir(filepath):\n            continue\n            \n        _, ext = os.path.splitext(filename)\n        moved = False\n        \n        for folder, ext_list in extensions.items():\n            if ext.lower() in ext_list:\n                target_folder = os.path.join(directorio, folder)\n                if not os.path.exists(target_folder):\n                    os.mkdir(target_folder)\n                    \n                shutil.move(filepath, os.path.join(target_folder, filename))\n                print(f"Movido: {filename} -> {folder}/")\n                moved = True\n                break\n        \n        if not moved:\n            print(f"Omitido: {filename} (Extensión desconocida)")\n\n# 3. Ejecutar\norganizar_archivos(base_dir)\nprint("\\n¡Organización completada!")\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código en tu IDE local.\n# 2. Verifica la carpeta \'downloads_test\' para ver las subcarpetas creadas.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),
        Lesson(
            id=115,
            title="Proyecto Final: Escáner de Red Avanzado (Nmap-like)",
            content='Estudia el siguiente código: Proyecto Final: Escáner de Red Avanzado (Nmap-like)',
            example_code='#!/usr/bin/python\n# --- IMPORTANTE: EJECUCIÓN LOCAL REQUERIDA ---\n# Este ejercicio requiere librerías externas o generar archivos.\n# Por favor, ejecútalo en tu IDE local (VS Code, PyCharm, etc).\n# -----------------------------------------------------\n# PROYECTO FINAL: Escáner de Red Avanzado (Estilo Nmap)\n# Objetivo: Crear una herramienta educativa que imite la arquitectura de Nmap.\n# Conceptos: POO, Sockets, TCP Connect, Banner Grabbing, Probes.\n\nimport socket\nimport sys\nimport time\nimport random\n\n# --- CLASES DEL ESCÁNER ---\n\nclass Target:\n    """\n    Representa el objetivo a escanear.\n    Se encarga de resolver el nombre de dominio a una IP.\n    """\n    def __init__(self, host):\n        self.host = host\n        self.ip = self._resolve_ip(host)\n        self.open_ports = []\n\n    def _resolve_ip(self, host):\n        """Convierte un hostname (google.com) a IP (142.250.x.x)."""\n        try:\n            # socket.gethostbyname realiza la consulta DNS\n            return socket.gethostbyname(host)\n        except socket.gaierror:\n            return None\n\nclass ServiceDetector:\n    """\n    Módulo encargado de detectar versiones de servicios (-sV).\n    Intenta \'hablar\' con el puerto abierto para ver qué responde.\n    """\n    def __init__(self):\n        # Diccionario de \'Probes\' (Sondas).\n        # Si el puerto no saluda, le enviamos esto para provocar una respuesta.\n        self.probes = {\n            80: b"HEAD / HTTP/1.0\\r\\n\\r\\n",   # Petición HTTP básica\n            443: b"HEAD / HTTP/1.0\\r\\n\\r\\n",  # Petición HTTPS básica\n            8080: b"GET / HTTP/1.0\\r\\n\\r\\n"   # Otra variante HTTP\n        }\n\n    def grab_banner(self, ip, port, timeout=2.0):\n        """Intenta obtener el banner (mensaje de bienvenida) del servicio."""\n        try:\n            # Creamos un nuevo socket solo para esta prueba\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(timeout)\n            s.connect((ip, port))\n            \n            # 1. Escucha Pasiva: Esperar saludo inicial\n            # Protocolos como SSH, FTP, SMTP suelen enviar un banner al conectarse.\n            try:\n                banner = s.recv(1024).decode().strip()\n                if banner:\n                    s.close()\n                    return banner\n            except socket.timeout:\n                pass # El servidor espera que nosotros hablemos primero (ej. HTTP)\n            \n            # 2. Escucha Activa: Enviar probe\n            # Si no hubo saludo, enviamos datos según el puerto para provocar respuesta.\n            probe = self.probes.get(port, b"\\r\\n") # Por defecto enviamos un enter\n            s.send(probe)\n            \n            # 3. Leer respuesta provocada\n            banner = s.recv(1024).decode().strip()\n            s.close()\n            return banner\n            \n        except Exception:\n            return None\n\nclass NmapScanner:\n    """Clase principal que orquesta todo el proceso de escaneo."""\n    def __init__(self):\n        self.detector = ServiceDetector()\n\n    def scan(self, target_str, ports, mode="SYN"):\n        print(f"\\nIniciando escaneo en {target_str}...")\n        target = Target(target_str)\n        \n        if not target.ip:\n            print(f"[!] Error: No se pudo resolver el host {target_str}")\n            return\n            \n        print(f"[+] IP Objetivo: {target.ip}")\n        print(f"[+] Puertos a escanear: {len(ports)}")\n        print("-" * 70)\n        print(f"{\'PUERTO\':<10} {\'ESTADO\':<10} {\'SERVICIO\':<20} {\'VERSIÓN\'}")\n        print("-" * 70)\n\n        start_time = time.time()\n        \n        # Iteramos sobre cada puerto seleccionado\n        for port in ports:\n            self._scan_port(target, port, mode)\n            \n        duration = time.time() - start_time\n        print("-" * 70)\n        print(f"Escaneo completado en {duration:.2f} segundos.")\n        print(f"Puertos abiertos encontrados: {len(target.open_ports)}")\n\n    def _scan_port(self, target, port, mode):\n        try:\n            # --- TCP CONNECT SCAN (-sT) ---\n            # Esta es la técnica más básica. El sistema operativo intenta\n            # completar la conexión TCP (3-way handshake).\n            # Si tiene éxito (0), el puerto está ABIERTO.\n            \n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(0.5) # Timeout corto para agilizar el escaneo\n            \n            # connect_ex devuelve 0 si hay éxito, o un código de error si falla\n            result = s.connect_ex((target.ip, port))\n            \n            if result == 0:\n                state = "OPEN"\n                service = self._guess_service(port)\n                version = ""\n                \n                # --- VERSION DETECTION (-sV) ---\n                # Si el puerto está abierto y el usuario pidió versiones,\n                # lanzamos el detector de servicios.\n                if mode == "VERSION":\n                    banner = self.detector.grab_banner(target.ip, port)\n                    if banner:\n                        version = banner[:40] # Cortamos si es muy largo\n                \n                print(f"{str(port)+\'/tcp\':<10} {state:<10} {service:<20} {version}")\n                target.open_ports.append(port)\n            \n            s.close() # ¡Importante! Cerrar el socket siempre.\n            \n        except KeyboardInterrupt:\n            print("\\n[!] Escaneo interrumpido por usuario.")\n            sys.exit()\n        except Exception as e:\n            pass\n\n    def _guess_service(self, port):\n        """Devuelve el nombre común del servicio basado en el número de puerto."""\n        services = {\n            21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp",\n            53: "domain", 80: "http", 443: "https", 3306: "mysql",\n            8080: "http-proxy", 8000: "http-alt"\n        }\n        return services.get(port, "unknown")\n\n# --- UTILIDADES ---\n\ndef parse_ports(input_str):\n    """Convierte la entrada del usuario (ej. \'80, 443\') en una lista de enteros."""\n    if not input_str.strip():\n        # Si está vacío, devolvemos una lista de puertos \'Top\' por defecto\n        return [21, 22, 23, 25, 53, 80, 110, 139, 443, 445, 3306, 3389, 8000, 8080]\n\n    ports = set()\n    parts = input_str.split(\',\')\n    \n    for part in parts:\n        part = part.strip()\n        if \'-\' in part:\n            # Manejo de rangos (ej. 1-100)\n            try:\n                start, end = map(int, part.split(\'-\'))\n                ports.update(range(start, end + 1))\n            except ValueError:\n                pass\n        else:\n            # Manejo de puertos individuales\n            try:\n                ports.add(int(part))\n            except ValueError:\n                pass\n                \n    return sorted(list(ports))\n\n# --- INTERFAZ PRINCIPAL (BUCLE) ---\n\ndef main():\n    print("="*60)\n    print("   PY-NMAP LITE - Escáner de Red Educativo")\n    print("="*60)\n    \n    while True:\n        print("\\n--- MENÚ PRINCIPAL ---")\n        print(" [1] TCP Connect Scan (-sT) [Rápido - Solo puertos]")\n        print(" [2] Version Detection (-sV) [Lento - Detecta software]")\n        print(" [3] Salir")\n        \n        opcion = input("Selecciona una opción: ")\n        \n        if opcion == "3":\n            print("¡Hasta luego!")\n            break\n            \n        if opcion not in ["1", "2"]:\n            print("Opción no válida.")\n            continue\n            \n        mode = "VERSION" if opcion == "2" else "SYN"\n        \n        target_input = input("\\nObjetivo (IP/Hostname) [127.0.0.1]: ")\n        if not target_input: target_input = "127.0.0.1"\n        \n        print("\\nPuertos a escanear:")\n        print(" - Escribe una lista: 22, 80, 443")\n        print(" - Escribe un rango: 1-1000")\n        print(" - Presiona ENTER para escanear los puertos más comunes")\n        ports_input = input("Puertos: ")\n        \n        ports = parse_ports(ports_input)\n        \n        # Instanciamos y ejecutamos el escáner\n        scanner = NmapScanner()\n        scanner.scan(target_input, ports, mode)\n        \n        input("\\nPresiona ENTER para volver al menú...")\n\nif __name__ == "__main__":\n    main()\n\n# --- EJERCICIO INTERACTIVO ---\n# 1. Ejecuta el código.\n# 2. Selecciona la opción 2 para ver qué versiones de software corren en tu máquina.\n# 3. Lee los comentarios en la clase \'ServiceDetector\' para entender cómo funciona el Banner Grabbing.\n',
            exercise_prompt="Ejecuta el código y analiza su funcionamiento.",
            validator=lambda code: (True, "¡Ejercicio completado!"),
            hint="Consulta el repositorio oficial para más contexto.",
            type="interactive"
        ),    ]
)
