export const STATIC_QA_DATA = [
    // SECCI√ìN 1 ‚Äî Preguntas generales b√°sicas
    {
        "q": "¬øQui√©n eres?",
        "a": "Soy una IA integrada en este curso de Python. Estoy aqu√≠ para ayudarte a entender el ejercicio en el que est√°s y guiarte paso a paso mientras practicas."
    },
    {
        "q": "¬øC√≥mo te llamas?",
        "a": "Soy tu asistente de Python dentro del curso. Mi nombre cambia seg√∫n la secci√≥n, pero siempre estoy aqu√≠ para ayudarte."
    },
    {
        "q": "¬øQu√© haces?",
        "a": "Te explico los ejercicios, aclaro dudas, doy pistas y reviso lo que est√°s aprendiendo en el m√≥dulo actual."
    },
    {
        "q": "¬øCu√°l es tu funci√≥n en este curso?",
        "a": "Mi funci√≥n es acompa√±arte en cada ejercicio, ayudarte a comprender el c√≥digo y resolver tus dudas sin que tengas que pegar nada: yo ya veo lo que est√°s haciendo."
    },
    {
        "q": "¬øA qu√© te dedicas exactamente?",
        "a": "Me dedico a guiarte en el aprendizaje de Python, explicando conceptos, corrigiendo errores y d√°ndote ejemplos cuando lo necesites."
    },
    {
        "q": "¬øQu√© tal est√°s?",
        "a": "¬°Listo para ayudarte con este ejercicio! Cuando quieras, preg√∫ntame lo que necesites."
    },
    {
        "q": "H√°blame de ti.",
        "a": "Soy un asistente creado para este curso. Mi especialidad es darte explicaciones r√°pidas, claras y adaptadas al ejercicio actual."
    },
    {
        "q": "Cu√©ntame algo.",
        "a": "¬øSab√≠as que Python fue creado como un lenguaje simple y legible? Por eso es perfecto para aprender programaci√≥n, justo como lo est√°s haciendo ahora."
    },
    {
        "q": "Cu√©ntame un chiste.",
        "a": "¬øPor qu√© el programador no puede salir de la ducha?\nPorque el champ√∫ dice ‚Äúaplica, enjuaga y repite‚Äù. üòÑ"
    },
    {
        "q": "Expl√≠came qu√© est√°s viendo exactamente.",
        "a": "Estoy viendo el ejercicio del m√≥dulo en el que est√°s ahora, incluyendo el c√≥digo y las instrucciones oficiales."
    },

    // SECCI√ìN 2 ‚Äî Preguntas sobre el ejercicio (gen√©ricas para cualquier m√≥dulo)
    {
        "q": "¬øDe qu√© trata este ejercicio?",
        "a": "Este ejercicio est√° dise√±ado para practicar el concepto principal del m√≥dulo, aplic√°ndolo directamente en el c√≥digo que ya tienes visible."
    },
    {
        "q": "¬øCu√°l es el objetivo del ejercicio?",
        "a": "Que puedas comprender y aplicar la idea central: puede ser variables, funciones, bucles, listas, automatizaci√≥n o cualquier tema del m√≥dulo en curso."
    },
    {
        "q": "¬øPara qu√© sirve este ejercicio?",
        "a": "Sirve para reforzar la teor√≠a mediante pr√°ctica guiada, usando un ejemplo real dentro del editor."
    },
    {
        "q": "Res√∫meme este ejercicio.",
        "a": "En este ejercicio debes ejecutar el c√≥digo, observar su resultado y entender c√≥mo se relaciona con el concepto explicado en este m√≥dulo."
    },
    {
        "q": "¬øQu√© tengo que hacer exactamente?",
        "a": "Sigue las indicaciones que aparecen justo encima del c√≥digo: suelen pedirte leer, ejecutar, modificar o analizar algo."
    },
    {
        "q": "¬øCu√°l es la parte m√°s importante del ejercicio?",
        "a": "La parte clave es entender c√≥mo funciona el bloque de c√≥digo que est√°s viendo y c√≥mo se relaciona con el tema que est√°s aprendiendo."
    },
    {
        "q": "Dame una pista sin decirme la soluci√≥n.",
        "a": "Piensa en c√≥mo funciona este concepto en Python y qu√© efecto tiene en el c√≥digo que est√°s viendo."
    },
    {
        "q": "¬øEst√° bien lo que hice?",
        "a": "Yo puedo ver tu ejercicio actual, as√≠ que si necesitas, puedo revisar la l√≥gica y comentarte si va en la direcci√≥n correcta."
    },
    {
        "q": "¬øMe puedes explicar paso a paso el ejercicio?",
        "a": "Claro: puedo desglosarlo en partes sencillas y seguirte en cada paso sin que tengas que copiar nada."
    },
    {
        "q": "¬øQu√© hago ahora?",
        "a": "Sigue la siguiente instrucci√≥n marcada en el ejercicio, o preg√∫ntame por la parte en la que tengas dudas."
    },

    // SECCI√ìN 3 ‚Äî Interacciones r√°pidas (para el chat express)
    {
        "q": "Dime la teor√≠a b√°sica de este ejercicio.",
        "a": "La teor√≠a principal aqu√≠ es comprender c√≥mo funciona este concepto de Python y c√≥mo se refleja en el c√≥digo que tienes en pantalla."
    },
    {
        "q": "Dame una explicaci√≥n r√°pida.",
        "a": "Este ejercicio te muestra un ejemplo pr√°ctico del concepto del m√≥dulo. Observa qu√© hace el c√≥digo, ejec√∫talo y detecta la relaci√≥n con la teor√≠a."
    },
    {
        "q": "Respuesta corta: ¬øqu√© hace este c√≥digo?",
        "a": "Realiza exactamente la acci√≥n que ves en pantalla, basada en el tema del ejercicio (variables, bucles, funciones, etc.)."
    },
    {
        "q": "Dame un consejo para este tipo de ejercicios.",
        "a": "Siempre analiza primero qu√© pretende demostrar el c√≥digo antes de modificarlo."
    },
    {
        "q": "Estoy perdido.",
        "a": "No te preocupes, puedo guiarte. Dime qu√© parte del ejercicio quieres entender mejor y te la explico de forma clara."
    },

    // SECCI√ìN 4 ‚Äî M√≥dulo 00 (Bienvenida y Herramientas)
    {
        "q": "¬øQu√© es el M√≥dulo 00?",
        "a": "Es la bienvenida. Configuras tu entorno y conoces la filosof√≠a del curso."
    },
    {
        "q": "¬øQu√© herramientas necesito?",
        "a": "Recomiendo VSCode, PyCharm o Thonny. Lo vital es experimentar y no tener miedo a romper el c√≥digo."
    },
    {
        "q": "¬øQu√© es PythonSecOS?",
        "a": "Es la simulaci√≥n inmersiva del curso. Un 'sistema operativo' donde entrenar√°s tus habilidades de ciberseguridad."
    },
    {
        "q": "¬øQu√© voy a aprender?",
        "a": "Python desde cero hasta scripts de automatizaci√≥n, herramientas de hacking √©tico y an√°lisis forense."
    },
    {
        "q": "¬øC√≥mo empiezo?",
        "a": "Lee la gu√≠a en el editor y pulsa 'Ejecutar' para iniciar el protocolo de bienvenida."
    },

    // SECCI√ìN 5 ‚Äî M√≥dulo 01 (Introducci√≥n)
    {
        "q": "¬øQu√© es print()?",
        "a": "Es la funci√≥n para mostrar texto o resultados en la consola. Ejemplo: `print('Hola')`."
    },
    {
        "q": "¬øQu√© son las variables?",
        "a": "Son contenedores para guardar datos. Se crean asignando un valor: `nombre = 'Carlos'`."
    },
    {
        "q": "¬øCu√°les son los tipos de datos b√°sicos?",
        "a": "Los principales son: `int` (enteros), `float` (decimales), `str` (texto) y `bool` (verdadero/falso)."
    },
    {
        "q": "¬øQu√© es una variable?",
        "a": "Es un contenedor para guardar datos. Se crea asignando un valor: `nombre = 'Carlos'`."
    },
    {
        "q": "¬øQu√© es un string?",
        "a": "Es una cadena de texto. Se escribe entre comillas: `'Hola'` o `\"Hola\"`."
    },
    {
        "q": "¬øQu√© es un int?",
        "a": "Es un n√∫mero entero (sin decimales), como `10`, `0` o `-5`."
    },
    {
        "q": "¬øQu√© es un float?",
        "a": "Es un n√∫mero decimal (punto flotante), como `3.14` o `2.5`."
    },
    {
        "q": "¬øQu√© es un boolean?",
        "a": "Es un valor de verdad: `True` (verdadero) o `False` (falso)."
    },
    {
        "q": "¬øQu√© es una lista?",
        "a": "Es una colecci√≥n ordenada de elementos. Se usa corchetes: `[1, 2, 3]`."
    },
    {
        "q": "¬øC√≥mo pido datos al usuario?",
        "a": "Usa la funci√≥n `input()`. Ejemplo: `nombre = input('¬øTu nombre?')`."
    },
    {
        "q": "¬øQu√© es el casting?",
        "a": "Es convertir un tipo de dato a otro. Ejemplo: `int('5')` convierte el texto '5' al n√∫mero 5."
    },
    {
        "q": "¬øC√≥mo comento el c√≥digo?",
        "a": "Usa `#` para comentarios de una l√≠nea. Python ignorar√° todo lo que escribas despu√©s."
    },

    // SECCI√ìN 6 ‚Äî FAQ General Python
    {
        "q": "¬øExiste un depurador a nivel de c√≥digo fuente con puntos de interrupci√≥n, depuraci√≥n paso a paso, etc?",
        "a": "S√≠.\nDebajo se describen algunos depuradores para Python y la funci√≥n integrada breakpoint() te permite ejecutar alguno de ellos.\nEl m√≥dulo pdb es en depurador en modo consola simple pero conveniente para Python. Es parte de la biblioteca est√°ndar de Python y est√° documentado en el manual de referencia de la biblioteca. Puedes escribir tu propio depurador usando el c√≥digo de pdb como ejemplo.\nThe IDLE interactive development environment, which is part of the standard Python distribution (normally available as Tools/scripts/idle3), includes a graphical debugger.\nPythonWin es un IDE Python que incluye un depurador con GUI basado en pdb. El depurador PythonWin colorea los puntos de interrupci√≥n y dispone de caracter√≠sticas geniales como la depuraci√≥n de programas no modificados mediante PythonWin. PythonWin est√° disponible como parte del proyecto Las extensiones de Python para Windows y como parte de la distribuci√≥n ActivePython.\nEric is an IDE built on PyQt and the Scintilla editing component.\ntrepan3k es un depurador similar a gdb.\nVisual Studio Code es un IDE con herramientas de depuraci√≥n que se integra con software de control de versiones.\nExisten varios IDEs comerciales para Python que incluyen depuradores gr√°ficos. Entre ellos tenemos:\nIDE Wing\nIDE Komodo\nPyCharm"
    },
    {
        "q": "¬øExiste alguna herramienta que ayude a encontrar errores o realizar an√°lisis est√°tico?",
        "a": "S√≠.\nPylint and Pyflakes do basic checking that will help you catch bugs sooner.\nStatic type checkers such as Mypy, Pyre, and Pytype can check type hints in Python source code."
    },
    {
        "q": "¬øC√≥mo puedo crear un binario independiente a partir de un programa Python?",
        "a": "No necesitas tener la habilidad de compilar Python a c√≥digo C si lo √∫nico que necesitas es un programa independiente que los usuarios puedan descargar y ejecutar sin necesidad de instalar primero una distribuci√≥n Python. Existe una serie de herramientas que determinan el conjunto de m√≥dulos que necesita un programa y une estos m√≥dulos conjuntamente con un binario Python para generar un √∫nico ejecutable.\nOne is to use the freeze tool, which is included in the Python source tree as Tools/freeze. It converts Python byte code to C arrays; with a C compiler you can embed all your modules into a new program, which is then linked with the standard Python modules.\nFunciona escaneando su fuente de forma recursiva en busca de declaraciones de importaci√≥n (en ambas formas) y buscando los m√≥dulos en la ruta est√°ndar de Python, as√≠ como en el directorio de la fuente (para los m√≥dulos incorporados). Luego convierte el bytecode de los m√≥dulos escritos en Python en c√≥digo C (inicializadores de arrays que pueden ser convertidos en objetos de c√≥digo usando el m√≥dulo marshal) y crea un archivo de configuraci√≥n a medida que s√≥lo contiene aquellos m√≥dulos incorporados que se usan realmente en el programa. A continuaci√≥n, compila el c√≥digo C generado y lo enlaza con el resto del int√©rprete de Python para formar un binario aut√≥nomo que act√∫a exactamente igual que su script.\nLos siguientes paquetes pueden ayudar con la creaci√≥n de ejecutables de consola y GUI:\nNuitka (Multiplataforma)\nPyInstaller (Cross-platform)\nPyOxidizer (Multiplataforma)\ncx_Freeze (Multiplataforma)\npy2app (macOS solamente)\npy2exe (Windows only)"
    },
    {
        "q": "¬øExisten est√°ndares de c√≥digo o una gu√≠a de estilo para programas Python?",
        "a": "S√≠. El estilo de c√≥digo requerido para los m√≥dulos de la biblioteca est√°ndar se encuentra documentado como PEP 8.\nN√∫cleo del lenguaje"
    },
    {
        "q": "¬øPor qu√© obtengo un UnboundLocalError cuando la variable tiene un valor?",
        "a": "It can be a surprise to get the UnboundLocalError in previously working code when it is modified by adding an assignment statement somewhere in the body of a function.\nEste c√≥digo:\nx = 10\ndef bar():\nprint(x)\nbar()\n10\nfunciona, pero este c√≥digo:\nx = 10\ndef foo():\nprint(x)\nx += 1\nresults in an UnboundLocalError:\nfoo()\nTraceback (most recent call last):\n...\nUnboundLocalError: local variable 'x' referenced before assignment\nEsto es debido a que cuando realizas una asignaci√≥n a una variable en un √°mbito de aplicaci√≥n, esa variable se convierte en local y enmascara cualquier variable llamada de forma similar en un √°mbito de aplicaci√≥n exterior. Desde la √∫ltima declaraci√≥n en foo asigna un nuevo valor a x, el compilador la reconoce como una variable local. Consecuentemente, cuando el print(x) m√°s pr√≥ximo intenta mostrar la variable local no inicializada se muestra un error.\nEn el ejemplo anterior puedes acceder al √°mbito de aplicaci√≥n exterior a la variable declar√°ndola como global:\nx = 10\ndef foobar():\nglobal x\nprint(x)\nx += 1\nfoobar()\n10\nEsta declaraci√≥n expl√≠cita es necesaria de cara a recordarte que (a diferencia de la situaci√≥n superficialmente an√°loga con las variables de clase e instancia) est√°s modificando el valor de la variable en un √°mbito de aplicaci√≥n m√°s externo:\nprint(x)\n11\nPuedes hacer algo similar en un √°mbito de aplicaci√≥n anidado usando la palabra clave nonlocal:\ndef foo():\nx = 10\ndef bar():\nnonlocal x\nprint(x)\nx += 1\nbar()\nprint(x)\nfoo()\n10\n11"
    },
    {
        "q": "¬øCu√°les son las reglas para las variables locales y globales en Python?",
        "a": "En Python, las variables que solo se encuentran referenciadas dentro de una funci√≥n son globales impl√≠citamente. Si a una variable se le asigna un valor en cualquier lugar dentro del cuerpo de una funci√≥n, se asumir√° que es local a no ser que expl√≠citamente se la declare como global.\nAunque, inicialmente, puede parecer sorprendente, un momento de consideraci√≥n permite explicar esto. Por una parte, requerir global para variables asignadas proporciona una barrera frente a efectos secundarios indeseados. Por otra parte, si global es requerido para todas las referencias globales, deber√°s usar global en todo momento. Deber√≠as declarar como global cualquier referencia a una funci√≥n integrada o a un componente de un m√≥dulo importado. Este embrollo arruinar√≠a la utilidad de la declaraci√≥n ¬´global¬ª para identificar los efectos secundarios."
    },
    {
        "q": "¬øPor qu√© las funciones lambda definidas en un bucle con diferentes valores devuelven todas el mismo resultado?",
        "a": "Considera que usas un bucle for para crear unas pocas funciones lambda (o, incluso, funciones normales), por ejemplo.:\nsquares = []\nfor x in range(5):\nsquares.append(lambda: x**2)\nLo siguiente proporciona una lista que contiene 5 funciones lambda que calculan x**2. Esperar√≠as que, cuando se les invoca, retornaran, respectivamente, 0, 1, 4, 9 y 16. Sin embargo, cuando lo ejecutes ver√°s que todas devuelven 16:\nsquares[2]()\n16\nsquares[4]()\n16\nEsto sucede porque x no es una funci√≥n lambda local pero se encuentra definida en un √°mbito de aplicaci√≥n externo y se accede cuando la lambda es invocada ‚Äî no cuando ha sido definida. Al final del bucle, el valor de x es 4, por tanto, ahora todas las funciones devuelven 4**2, i.e. 16. Tambi√©n puedes verificar esto mediante el cambio del valor de x y ver como los resultados de las lambdas cambian:\nx = 8\nsquares[2]()\n64\nDe cara a evitar esto necesitas guardar los valores en variables locales a las funciones lambda de tal forma que no dependan del valor de la x global:\nsquares = []\nfor x in range(5):\nsquares.append(lambda n=x: n**2)\nAqu√≠, n=x crea una nueva variable n local a la funci√≥n lambda y ejecutada cuando la funci√≥n lambda se define de tal forma que tiene el mismo valor que ten√≠a x en ese punto en el bucle. Esto significa que el valor de n ser√° 0 en la primera funci√≥n lambda, 1 en la segunda, 2 en la tercera y as√≠ sucesivamente. Por tanto, ahora cada lambda retornar√° el resultado correcto:\nsquares[2]()\n4\nsquares[4]()\n16\nEs de destacar que este comportamiento no es peculiar de las funciones lambda sino que aplica tambi√©n a las funciones regulares."
    },
    {
        "q": "¬øC√≥mo puedo compartir variables globales entre m√≥dulos?",
        "a": "La forma can√≥nica de compartir informaci√≥n entre m√≥dulos dentro de un mismo programa ser√≠a creando un m√≥dulo especial (a menudo llamado config o cfg). Simplemente importa el m√≥dulo config en todos los m√≥dulos de tu aplicaci√≥n; el m√≥dulo estar√° disponible como un nombre global. Debido a que solo hay una instancia de cada m√≥dulo, cualquier cambio hecho en el objeto m√≥dulo se reflejar√° en todos los sitios. Por ejemplo:\nconfig.py:\nx = 0   # Default value of the 'x' configuration setting\nmod.py:\nimport config\nconfig.x = 1\nmain.py:\nimport config\nimport mod\nprint(config.x)\nNote that using a module is also the basis for implementing the singleton design pattern, for the same reason."
    },
    {
        "q": "¬øCu√°les son las ¬´buenas pr√°cticas¬ª para usar import en un m√≥dulo?",
        "a": "En general, no uses from modulename import *. Haciendo eso embarulla el espacio de nombres del importador y hace que sea m√°s dif√≠cil para los linters el detectar los nombres sin definir.\nImportar los m√≥dulos en la parte inicial del fichero. Haci√©ndolo as√≠ deja claro los m√≥dulos que son necesarios para tu c√≥digo y evita preguntas sobre si el nombre del m√≥dulo se encuentra en el √°mbito de la aplicaci√≥n. Usar una importaci√≥n por l√≠nea hace que sea sencillo a√±adir y eliminar m√≥dulos importados pero usar m√∫ltiples importaciones por l√≠nea usa menos espacio de pantalla.\nEs una buena pr√°ctica si importas los m√≥dulos en el orden siguiente:\nstandard library modules ‚Äì e.g. sys, os, argparse, re\nthird-party library modules (anything installed in Python‚Äôs site-packages directory) ‚Äì e.g. dateutil, requests, PIL.Image\nlocally developed modules\nHay veces en que es necesario mover las importaciones a una funci√≥n o clase para evitar problemas de importaciones circulares. Gordon McMillan dice:\nNo hay problema con las importaciones circulares cuando ambos m√≥dulos usan la forma de importaci√≥n ¬´import <module>¬ª. Fallar√° cuando el segundo m√≥dulo quiera coger un nombre del primer m√≥dulo (¬´from module import name¬ª) y la importaci√≥n se encuentre en el nivel superior. Esto sucede porque los nombres en el primero todav√≠a no se encuentran disponibles debido a que el primer m√≥dulo se encuentra ocupado importando al segundo.\nEn este caso, si el segundo m√≥dulo se usa solamente desde una funci√≥n, la importaci√≥n se puede mover de forma sencilla dentro de la funci√≥n. En el momento en que se invoca a la importaci√≥n el primer m√≥dulo habr√° terminado de inicializarse y el segundo m√≥dulo podr√° hacer la importaci√≥n.\nTambi√©n podr√≠a ser necesario mover importaciones fuera del nivel superior del c√≥digo si alguno de loa m√≥dulos son espec√≠ficos a la plataforma. En ese caso podr√≠a, incluso, no ser posible importar todos los m√≥dulos en la parte superior del fichero. Para esos casos, la importaci√≥n correcta de los m√≥dulos en el c√≥digo correspondiente espec√≠fico de la plataforma es una buena opci√≥n.\nSolo debes mover importaciones a un √°mbito de aplicaci√≥n local, como dentro de la definici√≥n de una funci√≥n, si es necesario resolver problemas como una importaci√≥n circular o al intentar reducir el tiempo de inicializaci√≥n de un m√≥dulo. Esta t√©cnica es especialmente √∫til si muchas de las importaciones no son necesarias dependiendo de c√≥mo se ejecute el programa. Tambi√©n podr√≠as mover importaciones a una funci√≥n si los m√≥dulos solo se usan dentro de esa funci√≥n. N√≥tese que la primera carga de un m√≥dulo puede ser costosa debido al tiempo necesario para la inicializaci√≥n del m√≥dulo,pero la carga de un m√≥dulo m√∫ltiples veces est√° pr√°cticamente libre de coste ya que solo es necesario hacer b√∫squedas en un diccionario. Incluso si el nombre del m√≥dulo ha salido del √°mbito de aplicaci√≥n el m√≥dulo se encuentre, probablemente, en sys.modules."
    },
    {
        "q": "¬øPor qu√© los valores por defecto se comparten entre objetos?",
        "a": "Este tipo de error golpea a menudo a programadores novatos. Considera esta funci√≥n:\ndef foo(mydict={}):  # Danger: shared reference to one dict for all calls\n... compute something ...\nmydict[key] = value\nreturn mydict\nLa primera vez que llamas a esta funci√≥n, mydict solamente contiene un √∫nico elemento. La segunda vez, mydict contiene dos elementos debido a que cuando comienza la ejecuci√≥n de foo(), mydict comienza conteniendo un elemento de partida.\nA menudo se esperar√≠a que una invocaci√≥n a una funci√≥n cree nuevos objetos para valores por defecto. Eso no es lo que realmente sucede. Los valores por defecto se crean exactamente una sola vez, cuando se define la funci√≥n. Se se cambia el objeto, como el diccionario en este ejemplo, posteriores invocaciones a la funci√≥n estar√°n referidas al objeto cambiado.\nPor definici√≥n, los objetos inmutables como n√∫meros, cadenas, tuplas y None est√°n asegurados frente al cambio. Cambios en objetos mutables como diccionarios, listas e instancias de clase pueden llevar a confusi√≥n.\nDebido a esta caracter√≠stica es una buena pr√°ctica de programaci√≥n el no usar valores mutables como valores por defecto. En su lugar usa None como valor por defecto dentro de la funci√≥n, comprueba si el par√°metro es None y crea una nueva lista/un nuevo diccionario/cualquier otras cosa que necesites. Por ejemplo, no escribas:\ndef foo(mydict={}):\n...\npero:\ndef foo(mydict=None):\nif mydict is None:\nmydict = {}  # create a new dict for local namespace\nEsta caracter√≠stica puede ser √∫til. Cuando tienes una funci√≥n que es muy costosa de ejecutar, una t√©cnica com√∫n es cachear sus par√°metros y el valor resultante de cada invocaci√≥n a la funci√≥n y retornar el valor cacheado si se solicita nuevamente el mismo valor. A esto se le llama ¬´memoizing¬ª y se puede implementar de la siguiente forma:\n# Callers can only provide two parameters and optionally pass _cache by keyword\ndef expensive(arg1, arg2, *, _cache={}):\nif (arg1, arg2) in _cache:\nreturn _cache[(arg1, arg2)]\n# Calculate the value\nresult = ... expensive computation ...\n_cache[(arg1, arg2)] = result           # Store result in the cache\nreturn result\nPodr√≠as usar una variable global conteniendo un diccionario en lugar de un valor por defecto; es una cuesti√≥n de gustos."
    },
    {
        "q": "¬øC√≥mo puedo pasar par√°metros por palabra clave u opcionales de una funci√≥n a otra?",
        "a": "Recopila los argumentos usando los especificadores * y ** en la lista de par√°metros de la funci√≥n; esto te proporciona los argumentos posicionales como una tupla y los argumentos con palabras clave como un diccionario. Puedes, entonces, pasar estos argumentos cuando invoques a otra funci√≥n usando * y **:\ndef f(x, *args, **kwargs):\n...\nkwargs['width'] = '14.3c'\n...\ng(x, *args, **kwargs)"
    },
    {
        "q": "¬øCu√°l es la diferencia entre argumentos y par√°metros?",
        "a": "Parameters are defined by the names that appear in a function definition, whereas arguments are the values actually passed to a function when calling it. Parameters define what kind of arguments a function can accept. For example, given the function definition:\ndef func(foo, bar=None, **kwargs):\npass\nfoo, bar y kwargs son par√°metros de func. Sin embargo, cuando invocamos a func, por ejemplo:\nfunc(42, bar=314, extra=somevar)\nlos valores 42, 314 y somevar son argumentos."
    },
    {
        "q": "¬øPor qu√© cambiando la lista ‚Äúy‚Äù cambia, tambi√©n, la lista ‚Äúx‚Äù?",
        "a": "Si escribes c√≥digo como:\nx = []\ny = x\ny.append(10)\ny\n[10]\nx\n[10]\nte estar√°s preguntando porque a√±adir un elemento a y ha cambiado tambi√©n a x.\nHay dos factores que provocan este resultado:\nLas variables son simplemente nombres que referencian a objetos. Haciendo y = x no crea una copia de la lista ‚Äì crea una nueva variable y que referencia al mismo objeto al que referencia x . Esto significa que solo existe un objeto (la lista) y tanto x como y hacen referencia al mismo.\nLas listas son mutable, lo que significa que puedes cambiar su contenido.\nAfter the call to append(), the content of the mutable object has changed from [] to [10]. Since both the variables refer to the same object, using either name accesses the modified value [10].\nSi, por otra parte, asignamos un objeto inmutable a x:\nx = 5  # ints are immutable\ny = x\nx = x + 1  # 5 can't be mutated, we are creating a new object here\nx\n6\ny\n5\npodemos ver que x e y ya no son iguales. Esto es debido a que los enteros son immutable, y cuando hacemos x = x + 1 no estamos mutando el entero 5 incrementando su valor; en su lugar, estamos creando un nuevo objeto (el entero 6) y se lo asignamos a x (esto es, cambiando el objeto al cual referencia x). Despu√©s de esta asignaci√≥n tenemos dos objetos (los enteros 6 y 5) y dos variables que referencian a ellos (x ahora referencia a 6 pero y todav√≠a referencia a 5).\nSome operations (for example y.append(10) and y.sort()) mutate the object, whereas superficially similar operations (for example y = y + [10] and sorted(y)) create a new object. In general in Python (and in all cases in the standard library) a method that mutates an object will return None to help avoid getting the two types of operations confused. So if you mistakenly write y.sort() thinking it will give you a sorted copy of y, you‚Äôll instead end up with None, which will likely cause your program to generate an easily diagnosed error.\nSin embargo, existe una clase de operaciones en las cuales la misma operaci√≥n tiene, a veces, distintos comportamientos con diferentes tipos: los operadores de asignaci√≥n aumentada. Por ejemplo, += muta listas pero no tuplas o enteros (a_list += [1, 2, 3] es equivalente a a_list.extend([1, 2, 3]) y muta a_list, mientras que some_tuple += (1, 2, 3) y some_int += 1 crea nuevos objetos).\nEn otras palabras:\nSi tenemos un objeto mutable (list, dict, set, etc.), podemos usar algunas operaciones espec√≠ficas para mutarlo y todas las variables que referencian al mismo ver√°n el cambio reflejado.\nSi tenemos un objeto inmutable (str, int, tuple, etc.), todas las variables que referencian al mismo ver√°n siempre el mismo valor pero las operaciones que transforman ese valor en un nuevo valor siempre retornan un nuevo objeto.\nSi deseas saber si dos variables referencian o no al mismo objeto puedes usar el operador is o la funci√≥n incorporada id()."
    },
    {
        "q": "¬øC√≥mo puedo escribir una funci√≥n sin par√°metros (invocaci√≥n mediante referencia)?",
        "a": "Recuerda que los argumentos son pasados mediante asignaci√≥n en Python. Ya que las asignaciones simplemente crean referencias a objetos, no hay alias entre el nombre de un argumento en el invocador y el invocado y, por tanto, no hay invocaci√≥n por referencia per se. Puedes obtener el mismo efecto deseado de formas distintas.\nMediante el retorno de una tupla de resultados:\ndef func1(a, b):\na = 'new-value'        # a and b are local names\nb = b + 1              # assigned to new objects\nreturn a, b            # return new values\nx, y = 'old-value', 99\nfunc1(x, y)\n('new-value', 100)\nEsta es, casi siempre, la soluci√≥n m√°s clara.\nMediante el uso de variables globales. No es thread-safe y no se recomienda.\nPasando un objeto mutable (intercambiable en el mismo sitio):\ndef func2(a):\na[0] = 'new-value'     # 'a' references a mutable list\na[1] = a[1] + 1        # changes a shared object\nargs = ['old-value', 99]\nfunc2(args)\nargs\n['new-value', 100]\nPasando un diccionario que muta:\ndef func3(args):\nargs['a'] = 'new-value'     # args is a mutable dictionary\nargs['b'] = args['b'] + 1   # change it in-place\nargs = {'a': 'old-value', 'b': 99}\nfunc3(args)\nargs\n{'a': 'new-value', 'b': 100}\nO empaquetar valores en una instancia de clase:\nclass Namespace:\ndef __init__(self, /, **args):\nfor key, value in args.items():\nsetattr(self, key, value)\ndef func4(args):\nargs.a = 'new-value'        # args is a mutable Namespace\nargs.b = args.b + 1         # change object in-place\nargs = Namespace(a='old-value', b=99)\nfunc4(args)\nvars(args)\n{'a': 'new-value', 'b': 100}\nCasi nunca existe una buena raz√≥n para hacer esto tan complicado.\nTu mejor opci√≥n es retornar una tupla que contenga los m√∫ltiples resultados."
    },
    {
        "q": "¬øC√≥mo se puede hacer una funci√≥n de orden superior en Python?",
        "a": "Tienes dos opciones: puedes usar √°mbitos de aplicaci√≥n anidados o puedes usar objetos invocables. Por ejemplo, sup√≥n que quer√≠as definir linear(a,b) que devuelve una funci√≥n f(x) que calcula el valor a*x+b. Usar √°mbitos de aplicaci√≥n anidados:\ndef linear(a, b):\ndef result(x):\nreturn a * x + b\nreturn result\nO usar un objeto invocable:\nclass linear:\ndef __init__(self, a, b):\nself.a, self.b = a, b\ndef __call__(self, x):\nreturn self.a * x + self.b\nEn ambos casos,\ntaxes = linear(0.3, 2)\nnos da un objeto invocable donde taxes(10e6) == 0.3 * 10e6 + 2.\nEl enfoque del objeto invocable tiene la desventaja que es un ligeramente m√°s lento y el resultado es un c√≥digo levemente m√°s largo. Sin embargo, destacar que una colecci√≥n de invocables pueden compartir su firma v√≠a herencia:\nclass exponential(linear):\n# __init__ inherited\ndef __call__(self, x):\nreturn self.a * (x ** self.b)\nLos objetos pueden encapsular el estado de varios m√©todos:\nclass counter:\nvalue = 0\ndef set(self, x):\nself.value = x\ndef up(self):\nself.value = self.value + 1\ndef down(self):\nself.value = self.value - 1\ncount = counter()\ninc, dec, reset = count.up, count.down, count.set\nAqu√≠ inc(), dec() y reset() se comportan como funciones las cuales comparten la misma variable de conteo."
    },
    {
        "q": "¬øC√≥mo copio un objeto en Python?",
        "a": "En general, prueba copy.copy() o copy.deepcopy() para el caso general. No todos los objetos se pueden copiar pero la mayor√≠a s√≠ que pueden copiarse.\nAlgunas objetos se pueden copiar de forma m√°s sencilla. Los diccionarios disponen de un m√©todo copy():\nnewdict = olddict.copy()\nLas secuencias se pueden copiar usando un rebanado:\nnew_l = l[:]"
    },
    {
        "q": "¬øC√≥mo puedo encontrar los m√©todos o atributos de un objeto?",
        "a": "For an instance x of a user-defined class, dir(x) returns an alphabetized list of the names containing the instance attributes and methods and attributes defined by its class."
    },
    {
        "q": "¬øC√≥mo puede mi c√≥digo descubrir el nombre de un objeto?",
        "a": "Hablando de forma general no podr√≠an puesto que los objetos no disponen, realmente, de un nombre. Esencialmente, las asignaciones relacionan un nombre con su valor; Lo mismo se cumple con las declaraciones def y class pero, en este caso, el valor es un invocable. Considera el siguiente c√≥digo:\nclass A:\npass\nB = A\na = B()\nb = a\nprint(b)\n<__main__.A object at 0x16D07CC>\nprint(a)\n<__main__.A object at 0x16D07CC>\nArguably the class has a name: even though it is bound to two names and invoked through the name B the created instance is still reported as an instance of class A. However, it is impossible to say whether the instance‚Äôs name is a or b, since both names are bound to the same value.\nEn t√©rminos generales, no deber√≠a ser necesario que tu c√≥digo ¬´conozca los nombres¬ª de determinados valores. A menos que est√©s escribiendo deliberadamente programas introspectivos, esto suele ser una indicaci√≥n de que un cambio de enfoque podr√≠a ser beneficioso.\nEn comp.lang.python, Fredrik Lundh proporcion√≥ una vez una excelente analog√≠a en respuesta a esta pregunta:\nDe la misma forma que obtienes el nombre de ese gato que te has encontrado en tu porche el propio gato (objeto) no te puede indicar su nombre y, realmente, no importa ‚Äì por tanto, la √∫nica forma de encontrar c√≥mo se llama ser√≠a preguntando a todos los vecinos (espacios de nombres) si es su gato (objeto)‚Ä¶\n‚Ä¶y no te sorprendas si encuentras que se le conoce mediante diferentes nombres o ¬°nadie conoce su nombre!"
    },
    {
        "q": "¬øQu√© ocurre con la precedencia del operador coma?",
        "a": "La coma no es un operador en Python. Considera la sesi√≥n:\n\"a\" in \"b\", \"a\"\n(False, 'a')\nDebido a que la coma no es un operador sino un separador entre expresiones lo anterior se eval√∫e como se ha introducido:\n(\"a\" in \"b\"), \"a\"\nno:\n\"a\" in (\"b\", \"a\")\nLo mismo sucede con varios operadores de asignaci√≥n (=, +=, etc). No son realmente operadores sino delimitadores sint√°cticos en declaraciones de asignaci√≥n."
    },
    {
        "q": "¬øExiste un equivalente al operador ternario de C ¬´?:¬ª?",
        "a": "S√≠, existe. La sintaxis es como sigue:\n[on_true] if [expression] else [on_false]\nx, y = 50, 25\nsmall = x if x < y else y\nAntes de que esta sintaxis se introdujera en Python 2.5 una expresi√≥n com√∫n fue el uso de operadores l√≥gicos:\n[expression] and [on_true] or [on_false]\nSin embargo, esa expresi√≥n no es segura ya que puede retornar valores err√≥neos cuando on_true tiene un valor booleano falso. Por tanto, siempre es mejor usar la forma ... if ... else ...."
    },
    {
        "q": "¬øEs posible escribir expresiones en una l√≠nea de forma ofuscada en Python?",
        "a": "Yes. Usually this is done by nesting lambda within lambda. See the following three examples, slightly adapted from Ulf Bartelt:\nfrom functools import reduce\n# Primes < 1000\nprint(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\nmap(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n# First 10 Fibonacci numbers\nprint(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\nf(x,f), range(10))))\n# Mandelbrot set\nprint((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\n'+y,map(lambda y,\nIu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\nSx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\ni=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n>=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n#        V          V      |   |______ columns on screen\n#        |          |      |__________ maximum of \"iterations\"\n#        |          |_________________ range on y axis\n#        |____________________________ range on x axis\n¬°No prob√©is esto en casa, personitas!"
    },
    {
        "q": "¬øQu√© hace la barra (/) en medio de la lista de par√°metros de una funci√≥n?",
        "a": "A slash in the argument list of a function denotes that the parameters prior to it are positional-only. Positional-only parameters are the ones without an externally usable name. Upon calling a function that accepts positional-only parameters, arguments are mapped to parameters based solely on their position. For example, divmod() is a function that accepts positional-only parameters. Its documentation looks like this:\nhelp(divmod)\nHelp on built-in function divmod in module builtins:\ndivmod(x, y, /)\nReturn the tuple (x//y, x%y).  Invariant: div*y + mod == x.\nEl slash al final de la lista de par√°metros indica que los tres par√°metros son √∫nicamente posicionales. Por tanto, invocar a pow() con argumentos con palabra clave podr√≠a derivar en un error:\ndivmod(x=3, y=4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: divmod() takes no keyword arguments\nN√∫meros y cadenas"
    },
    {
        "q": "¬øC√≥mo puedo especificar enteros hexadecimales y octales?",
        "a": "Para especificar un d√≠gito octal, prefija el valor octal con un cero y una ¬´o¬ª en min√∫scula o may√∫scula. Por ejemplo, para definir la variable ¬´a¬ª con el valor octal ¬´10¬ª (8 en decimal), escribe:\na = 0o10\na\n8\nUn hexadecimal es igual de simple. Simplemente a√±ade un cero y una ¬´x¬ª, en min√∫scula o may√∫scula, antes del n√∫mero hexadecimal . Los d√≠gitos hexadecimales se pueden especificar en min√∫sculas o may√∫sculas. Por ejemplo, en el int√©rprete de Python:\na = 0xa5\na\n165\nb = 0XB2\nb\n178"
    },
    {
        "q": "¬øPor qu√© -22 // 10 devuelve -3?",
        "a": "Es debido, principalmente al deseo que i % j tenga el mismo signo que j. Si quieres eso y, adem√°s, quieres:\ni == (i // j) * j + (i % j)\nentonces la divisi√≥n entera a la baja debe retornar el valor base m√°s bajo. C tambi√©n requiere que esa identidad se mantenga de tal forma que cuando los compiladores truncan i // j necesitan que i % j tenga el mismo signo que i.\nExisten unos pocos casos para i % j cuando j es negativo. Cuando j es positivo, existen muchos casos y, virtualmente, en todos ellos es m√°s √∫til para i % j que sea >= 0. Si el reloj dice que ahora son las 10, ¬øqu√© dijo hace 200 horas? -190 % 12 == 2 es √∫til; -190 % 12 == -10 es un error listo para morderte."
    },
    {
        "q": "¬øC√≥mo puedo obtener un atributo int literal en lugar de SyntaxError?",
        "a": "Trying to lookup an int literal attribute in the normal manner gives a SyntaxError because the period is seen as a decimal point:\n1.__class__\nFile \"<stdin>\", line 1\n1.__class__\n^\nSyntaxError: invalid decimal literal\nLa soluci√≥n es separar el literal del punto con un espacio o un par√©ntesis.\n1 .__class__\n<class 'int'>\n(1).__class__\n<class 'int'>"
    },
    {
        "q": "¬øC√≥mo convierto una cadena a un n√∫mero?",
        "a": "For integers, use the built-in int() type constructor, e.g. int('144') == 144. Similarly, float() converts to a floating-point number, e.g. float('144') == 144.0.\nPor defecto, estas interpretan el n√∫mero como decimal de tal forma que int('0144') == 144 y int('0x144') lanzar√° ValueError. int(string, base) toma la base para convertirlo desde un segundo par√°metro opcional, por tanto int('0x144', 16) == 324. Si la base se especifica como 0, el n√∫mero se interpreta usando las reglas de Python‚Äôs rules: un prefijo ‚Äú0o‚Äù indica octal y un prefijo ‚Äú0x‚Äù indica un n√∫mero hexadecimal.\nNo uses la funci√≥n incorporada eval() si todo lo que necesitas es convertir cadenas a n√∫meros. eval() ser√° considerablemente m√°s lento y presenta riesgos de seguridad: cualquiera podr√≠a introducir una expresi√≥n Python que presentara efectos indeseados. Por ejemplo, alguien podr√≠a pasar __import__('os').system(\"rm -rf $HOME\") lo cual borrar√≠a el directorio home al completo.\neval() tambi√©n tiene el efecto de interpretar n√∫meros como expresiones Python , de tal forma que, por ejemplo, eval('09') dar√° un error de sintaxis porque Python no permite un ‚Äú0‚Äù inicial en un n√∫mero decimal (excepto ‚Äú0‚Äù)."
    },
    {
        "q": "¬øC√≥mo puedo convertir un n√∫mero a una cadena?",
        "a": "To convert, e.g., the number 144 to the string '144', use the built-in type constructor str(). If you want a hexadecimal or octal representation, use the built-in functions hex() or oct(). For fancy formatting, see the f-strings and Sintaxis de formateo de cadena sections, e.g. \"{:04d}\".format(144) yields '0144' and \"{:.3f}\".format(1.0/3.0) yields '0.333'."
    },
    {
        "q": "¬øC√≥mo puedo modificar una cadena in situ?",
        "a": "No puedes debido a que las cadenas son inmutables. En la mayor√≠a de situaciones solo deber√≠as crear una nueva cadena a partir de varias partes que quieras usar para crearla. Sin embargo, si necesitas un objeto con la habilidad de modificar en el mismo lugar datos unicode prueba usando el objeto io.StringIO o el m√≥dulo array:\nimport io\ns = \"Hello, world\"\nsio = io.StringIO(s)\nsio.getvalue()\n'Hello, world'\nsio.seek(7)\n7\nsio.write(\"there!\")\n6\nsio.getvalue()\n'Hello, there!'\nimport array\na = array.array('w', s)\nprint(a)\narray('w', 'Hello, world')\na[0] = 'y'\nprint(a)\narray('w', 'yello, world')\na.tounicode()\n'yello, world'"
    },
    {
        "q": "¬øC√≥mo puedo usar cadenas para invocar funciones/m√©todos?",
        "a": "Existen varias t√©cnicas.\nLo mejor ser√≠a usar un diccionario que mapee cadenas a funciones. La principal ventaja de esta t√©cnica es que las cadenas no necesitan ser iguales que los nombres de las funciones. Esta es tambi√©n la principal t√©cnica que se usa para emular un constructo case:\ndef a():\npass\ndef b():\npass\ndispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\ndispatch[get_input()]()  # Note trailing parens to call function\nUsa la funci√≥n incorporada getattr():\nimport foo\ngetattr(foo, 'bar')()\nN√≥tese que getattr() funciona en cualquier objeto, incluido clases, instancias de clases, m√≥dulos, etc.\nEsto se usa en varios lugares de la biblioteca est√°ndar, como esto:\nclass Foo:\ndef do_foo(self):\n...\ndef do_bar(self):\n...\nf = getattr(foo_instance, 'do_' + opname)\nf()\nUse locals() para resolver el nombre de la funci√≥n:\ndef myFunc():\nprint(\"hello\")\nfname = \"myFunc\"\nf = locals()[fname]\nf()"
    },
    {
        "q": "Is there an equivalent to Perl‚Äôs chomp() for removing trailing newlines from strings?",
        "a": "Puedes usar S.rstrip(\"\n\") para eliminar todas las ocurrencias de cualquier terminaci√≥n de l√≠nea desde el final de la cadena S sin eliminar el resto de espacios en blanco que le siguen. Si la cadena S representa m√°s de una l√≠nea con varias l√≠neas vac√≠as al final, las terminaciones de l√≠nea para todas las l√≠neas vac√≠as se eliminar√°n:\nlines = (\"line 1\n\"\n\"\n\"\n\"\n\")\nlines.rstrip(\"\n\")\n'line 1 '\nYa que esto solo ser√≠a deseable, t√≠picamente, cuando lees texto l√≠nea a l√≠nea, usar S.rstrip() de esta forma funcionar√≠a bien."
    },
    {
        "q": "Is there a scanf() or sscanf() equivalent?",
        "a": "No de la misma forma.\nFor simple input parsing, the easiest approach is usually to split the line into whitespace-delimited words using the split() method of string objects and then convert decimal strings to numeric values using int() or float(). split() supports an optional ¬´sep¬ª parameter which is useful if the line uses something other than whitespace as a separator.\nFor more complicated input parsing, regular expressions are more powerful than C‚Äôs sscanf and better suited for the task."
    },
    {
        "q": "What does UnicodeDecodeError or UnicodeEncodeError error mean?",
        "a": "Ver C√ìMO (HOWTO) Unicode."
    },
    {
        "q": "Can I end a raw string with an odd number of backslashes?",
        "a": "A raw string ending with an odd number of backslashes will escape the string‚Äôs quote:\nr'C:\this\\will\not\\work'\nFile \"<stdin>\", line 1\nr'C:\this\\will\not\\work'\n^\nSyntaxError: unterminated string literal (detected at line 1)\nThere are several workarounds for this. One is to use regular strings and double the backslashes:\n'C:\\this\\will\\work\\'\n'C:\\this\\will\\work\\'\nAnother is to concatenate a regular string containing an escaped backslash to the raw string:\nr'C:\this\\will\\work' '\\'\n'C:\\this\\will\\work\\'\nIt is also possible to use os.path.join() to append a backslash on Windows:\nos.path.join(r'C:\this\\will\\work', '')\n'C:\\this\\will\\work\\'\nNote that while a backslash will ¬´escape¬ª a quote for the purposes of determining where the raw string ends, no escaping occurs when interpreting the value of the raw string. That is, the backslash remains present in the value of the raw string:\nr'backslash'preserved'\n\"backslash\\'preserved\"\nAlso see the specification in the language reference.\nRendimiento"
    },
    {
        "q": "Mi programa es muy lento. ¬øC√≥mo puedo acelerarlo?",
        "a": "Esa es una pregunta dif√≠cil, en general. Primero, aqu√≠ tienes una lista de cosas a recordar antes de ir m√°s all√°:\nLas caracter√≠sticas del rendimiento var√≠an entre las distintas implementaciones de Python. Estas preguntas frecuentes se enfocan en CPython.\nEl comportamiento puede variar entre distintos sistemas operativos, especialmente cuando se habla de tareas I/O o multi-tarea.\nSiempre deber√≠as encontrar las partes importantes en tu programa antes de intentar optimizar el c√≥digo (ver el m√≥dulo profile).\nEscribir programas de comparaci√≥n del rendimiento te permitir√° iterar r√°pidamente cuando te encuentres buscando mejoras (ver el m√≥dulo timeit).\nEs altamente recomendable disponer de una buena cobertura de c√≥digo (a partir de pruebas unitarias o cualquier otra t√©cnica) antes de introducir potenciales regresiones ocultas en sofisticadas optimizaciones.\nDicho lo anterior, existen muchos trucos para acelerar c√≥digo Python. Aqu√≠ tienes algunos principios generales que te permitir√°n llegar a alcanzar niveles de rendimiento aceptables:\nEl hacer m√°s r√°pido tu algoritmo (o cambiarlo por alguno m√°s r√°pido) puede provocar mayores beneficios que intentar unos pocos trucos de micro-optimizaci√≥n a trav√©s de todo tu c√≥digo.\nUtiliza las estructuras de datos correctas. Estudia la documentaci√≥n para los Tipos integrados y el m√≥dulo collections.\nCuando la biblioteca est√°ndar proporciona una primitiva de hacer algo, esta supuestamente ser√° (aunque no se garantiza) m√°s r√°pida que cualquier otra alternativa que se te ocurra. Esto es doblemente cierto si las primitivas han sido escritas en C, como los builtins y algunos tipos extendidos. Por ejemplo, aseg√∫rate de usar el m√©todo integrado list.sort() o la funci√≥n relacionada sorted() para ordenar (y ver Sorting Techniques para ver ejemplos de uso moderadamente avanzados).\nLas abstracciones tienden a crear rodeos y fuerzan al int√©rprete a trabajar m√°s. Si el nivel de rodeos sobrepasa el trabajo √∫til realizado tu programa podr√≠a ser m√°s lento. Deber√≠as evitar abstracciones excesivas, especialmente, en forma de peque√±as funciones o m√©todos (que tambi√©n va en detrimento de la legibilidad).\nIf you have reached the limit of what pure Python can allow, there are tools to take you further away. For example, Cython can compile a slightly modified version of Python code into a C extension, and can be used on many different platforms. Cython can take advantage of compilation (and optional type annotations) to make your code significantly faster than when interpreted. If you are confident in your C programming skills, you can also write a C extension module yourself.\nVer tambi√©n La p√°gina de la wiki dedicada a trucos de rendimiento."
    },
    {
        "q": "¬øCu√°l es la forma m√°s eficiente de concatenar muchas cadenas conjuntamente?",
        "a": "Los objetos str y bytes son inmutables, por tanto, concatenar muchas cadenas en una sola es ineficiente debido a que cada concatenaci√≥n crea un nuevo objeto. En el caso m√°s general, el coste total en tiempo de ejecuci√≥n es cuadr√°tico en relaci√≥n a la longitud de la cadena final.\nPara acumular muchos objetos str, la forma recomendada ser√≠a colocarlos en una lista y llamar al m√©todo str.join() al final:\nchunks = []\nfor s in my_strings:\nchunks.append(s)\nresult = ''.join(chunks)\n(otra forma que ser√≠a razonable en t√©rminos de eficiencia ser√≠a usar io.StringIO)\nPara acumular muchos objetos bytes, la forma recomendada ser√≠a extender un objeto bytearray usando el operador de concatenaci√≥n in situ (el operador +=):\nresult = bytearray()\nfor b in my_bytes_objects:\nresult += b\nSecuencias (Tuplas/Listas)"
    },
    {
        "q": "¬øC√≥mo convertir entre tuplas y listas?",
        "a": "El constructor tuple(seq) convierte cualquier secuencia (en realidad, cualquier iterable) en una tupla con los mismos elementos y en el mismo orden.\nPor ejemplo, tuple([1, 2, 3]) lo convierte en (1, 2, 3) y tuple('abc') lo convierte en ('a', 'b', 'c'). Si el argumento es una tupla no crear√° una nueva copia y retornar√° el mismo objeto, por tanto, llamar a tuple() no tendr√° mucho coste si no est√°s seguro si un objeto ya es una tupla.\nEl constructor list(seq) convierte cualquier secuencia o iterable en una lista con los mismos elementos y en el mismo orden. Por ejemplo, list((1, 2, 3)) lo convierte a [1, 2, 3] y list('abc') lo convierte a ['a', 'b', 'c']. Si el argumento es una lista, har√° una copia como lo har√≠a seq[:]."
    },
    {
        "q": "¬øQu√© es un √≠ndice negativo?",
        "a": "Las secuencias en Python est√°n indexadas con n√∫meros positivos y negativos. Para los n√∫meros positivos el 0 ser√° el primer √≠ndice, el 1 el segundo y as√≠ en adelante. Para los √≠ndices negativos el -1 el √∫ltimo √≠ndice, el -2 el pen√∫ltimo, etc. Piensa en seq[-n] como si fuera seq[len(seq)-n].\nEl uso de √≠ndices negativos puede ser muy conveniente. Por ejemplo S[:-1] se usa para todo la cadena excepto para su √∫ltimo car√°cter, lo cual es √∫til para eliminar el salto de l√≠nea final de una cadena."
    },
    {
        "q": "¬øC√≥mo puedo iterar sobre una secuencia en orden inverso?",
        "a": "Usa la funci√≥n incorporada reversed():\nfor x in reversed(sequence):\n...  # do something with x ...\nEsto no transformar√° la secuencia original sino que crear√° una nueva copia en orden inverso por la que se puede iterar."
    },
    {
        "q": "¬øC√≥mo eliminar duplicados de una lista?",
        "a": "Puedes echar un vistazo al recetario de Python para ver una gran discusi√≥n mostrando muchas formas de hacer esto:\nhttps://code.activestate.com/recipes/52560/\nSi no te preocupa que la lista se reordene la puedes ordenar y, despu√©s, y despu√©s escanearla desde el final borrando duplicados a medida que avanzas:\nif mylist:\nmylist.sort()\nlast = mylist[-1]\nfor i in range(len(mylist)-2, -1, -1):\nif last == mylist[i]:\ndel mylist[i]\nelse:\nlast = mylist[i]\nSi todos los elementos de la lista pueden ser usados como claves (por ejemplo son todos hashable) esto ser√°, en general, m√°s r√°pido\nmylist = list(set(mylist))\nEsto convierte la lista en un conjunto eliminando, por tanto, los duplicados y, posteriormente, puedes volver a una lista.\nC√≥mo eliminar duplicados de una lista\nAl igual que con la eliminaci√≥n de duplicados, una posibilidad es iterar expl√≠citamente a la inversa con una condici√≥n de eliminaci√≥n. Sin embargo, es m√°s f√°cil y r√°pido utilizar el reemplazo de sectores con una iteraci√≥n directa impl√≠cita o expl√≠cita. Aqu√≠ hay tres variaciones.:\nmylist[:] = filter(keep_function, mylist)\nmylist[:] = (x for x in mylist if keep_condition)\nmylist[:] = [x for x in mylist if keep_condition]\nEsta comprensi√≥n de lista puede ser la m√°s r√°pida."
    },
    {
        "q": "¬øC√≥mo se puede hacer un array en Python?",
        "a": "Usa una lista:\n[\"this\", 1, \"is\", \"an\", \"array\"]\nLas listas son equivalentes en complejidad temporal a arrays en C o Pascal; La principal diferencia es que una lista en Python puede contener objetos de diferentes tipos.\nThe array module also provides methods for creating arrays of fixed types with compact representations, but they are slower to index than lists. Also note that NumPy and other third party packages define array-like structures with various characteristics as well.\nTo get Lisp-style linked lists, you can emulate cons cells using tuples:\nlisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )\nIf mutability is desired, you could use lists instead of tuples. Here the analogue of a Lisp car is lisp_list[0] and the analogue of cdr is lisp_list[1]. Only do this if you‚Äôre sure you really need to, because it‚Äôs usually a lot slower than using Python lists."
    },
    {
        "q": "¬øC√≥mo puedo crear una lista multidimensional?",
        "a": "Seguramente hayas intentado crear un array multidimensional de la siguiente forma:\nA = [[None] * 2] * 3\nEsto parece correcto si lo muestras en pantalla:\nA\n[[None, None], [None, None], [None, None]]\nPero cuando asignas un valor, se muestra en m√∫ltiples sitios:\nA[0][0] = 5\nA\n[[5, None], [5, None], [5, None]]\nLa raz√≥n es que replicar una lista con * no crea copias, solo crea referencias a los objetos existentes. El *3 crea una lista conteniendo 3 referencias a la misma lista de longitud dos. Cambios a una fila se mostrar√°n en todas las filas, lo cual, seguramente, no es lo que deseas.\nEl enfoque recomendado ser√≠a crear, primero, una lista de la longitud deseada y, despu√©s, rellenar cada elemento con una lista creada en ese momento:\nA = [None] * 3\nfor i in range(3):\nA[i] = [None] * 2\nEsto genera una lista conteniendo 3 listas distintas de longitud dos. Tambi√©n puedes usar una comprensi√≥n de lista:\nw, h = 2, 3\nA = [[None] * w for i in range(h)]\nOr, you can use an extension that provides a matrix datatype; NumPy is the best known."
    },
    {
        "q": "How do I apply a method or function to a sequence of objects?",
        "a": "To call a method or function and accumulate the return values is a list, a list comprehension is an elegant solution:\nresult = [obj.method() for obj in mylist]\nresult = [function(obj) for obj in mylist]\nTo just run the method or function without saving the return values, a plain for loop will suffice:\nfor obj in mylist:\nobj.method()\nfor obj in mylist:\nfunction(obj)"
    },
    {
        "q": "¬øPor qu√© hacer lo siguiente, a_tuple[i] += ['item'], lanza una excepci√≥n cuando la suma funciona?",
        "a": "Esto es debido a la combinaci√≥n del hecho de que un operador de asignaci√≥n aumentada es un operador de asignaci√≥n y a la diferencia entre objetos mutables e inmutable en Python.\nEsta discusi√≥n aplica, en general, cuando los operadores de asignaci√≥n aumentada se aplican a elementos de una tupla que apuntan a objetos mutables. Pero vamos a usar una lista y += para el ejemplo.\nSi escribes:\na_tuple = (1, 2)\na_tuple[0] += 1\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\nLa raz√≥n por la que se produce la excepci√≥n deber√≠a ser evidente: 1 se a√±ade al objeto a_tuple[0] que apunta a (1), creando el objeto resultante, 2, pero cuando intentamos asignar el resultado del c√°lculo, 2, al elemento 0 de la tupla, obtenemos un error debido a que no podemos cambiar el elemento al que apunta la tupla.\nEn realidad, lo que esta declaraci√≥n de asignaci√≥n aumentada est√° haciendo es, aproximadamente, lo siguiente:\nresult = a_tuple[0] + 1\na_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\nEs la parte de asignaci√≥n de la operaci√≥n la que provoca el error, debido a que una tupla es inmutable.\nCuando escribes algo como lo siguiente:\na_tuple = (['foo'], 'bar')\na_tuple[0] += ['item']\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\nLa excepci√≥n es un poco m√°s sorprendente e, incluso, m√°s sorprendente es el hecho que aunque hubo un error, la agregaci√≥n funcion√≥:\na_tuple[0]\n['foo', 'item']\nTo see why this happens, you need to know that (a) if an object implements an __iadd__() magic method, it gets called when the += augmented assignment is executed, and its return value is what gets used in the assignment statement; and (b) for lists, __iadd__() is equivalent to calling extend() on the list and returning the list. That‚Äôs why we say that for lists, += is a ¬´shorthand¬ª for list.extend():\na_list = []\na_list += [1]\na_list\n[1]\nEsto es equivalente a\nresult = a_list.__iadd__([1])\na_list = result\nEl objeto al que apunta a_list ha mutado y el puntero al objeto mutado es asignado de vuelta a a_list. El resultado final de la asignaci√≥n no es opci√≥n debido a que es un puntero al mismo objeto al que estaba apuntando a_list pero la asignaci√≥n s√≠ que ocurre.\nPor tanto, en nuestro ejemplo con tupla lo que est√° pasando es equivalente a:\nresult = a_tuple[0].__iadd__(['item'])\na_tuple[0] = result\nTraceback (most recent call last):\n...\nTypeError: 'tuple' object does not support item assignment\nThe __iadd__() succeeds, and thus the list is extended, but even though result points to the same object that a_tuple[0] already points to, that final assignment still results in an error, because tuples are immutable."
    },
    {
        "q": "Quiero hacer una ordenaci√≥n compleja: ¬øPuedes hacer una transformada Schwartziana (Schwartzian Transform) en Python?",
        "a": "La t√©cnica, atribuida a Randal Schwartz, miembro de la comunidad Perl, ordena los elementos de una lista mediante una m√©trica que mapea cada elemento a su ¬´valor orden¬ª. En Python, usa el argumento key par el m√©todo list.sort():\nIsorted = L[:]\nIsorted.sort(key=lambda s: int(s[10:15]))"
    },
    {
        "q": "¬øC√≥mo puedo ordenar una lista a partir de valores de otra lista?",
        "a": "Las puedes unir en un iterador de tuplas, ordena la lista resultando y despu√©s extrae el elemento que deseas.\nlist1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\nlist2 = [\"something\", \"else\", \"to\", \"sort\"]\npairs = zip(list1, list2)\npairs = sorted(pairs)\npairs\n[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]\nresult = [x[1] for x in pairs]\nresult\n['else', 'sort', 'to', 'something']\nObjetos"
    },
    {
        "q": "¬øQu√© es una clase?",
        "a": "Una clase es un tipo de objeto particular creado mediante la ejecuci√≥n de la declaraci√≥n class. Los objetos class se usan como plantillas para crear instancias de objetos que son tanto los datos (atributos) como el c√≥digo (m√©todos) espec√≠ficos para un tipo de dato.\nUna clase puede estar basada en una o m√°s clases diferentes, llamadas su(s) clase(s). Hereda los atributos y m√©todos de sus clases base. Esto permite que se pueda refinar un objeto modelo de forma sucesiva mediante herencia. Puedes tener una clase gen√©rica Mailbox que proporciona m√©todos de acceso b√°sico para un buz√≥n de correo y subclases como MboxMailbox, MaildirMailbox, OutlookMailbox que gestionan distintos formatos espec√≠ficos de buz√≥n de correos."
    },
    {
        "q": "¬øQu√© es un m√©todo?",
        "a": "Un m√©todo es una funci√≥n de un objeto x que puedes llamar, normalmente, de la forma x.name(arguments...). Los m√©todos se definen como funciones dentro de la definici√≥n de la clase:\nclass C:\ndef meth(self, arg):\nreturn arg * 2 + self.attribute"
    },
    {
        "q": "¬øQu√© es self?",
        "a": "Self es, b√°sicamente, un nombre que se usa de forma convencional como primer argumento de un m√©todo. Un m√©todo definido como meth(self, a, b, c) se le llama como x.meth(a, b, c) para una instancia x de la clase es que se defini√≥; el m√©todo invocado pensar√° que se le ha invocado como meth(x, a, b, c).\nVer tambi√©n ¬øPor qu√© debe usarse ‚Äúself‚Äù expl√≠citamente en las definiciones y llamadas de m√©todos?."
    },
    {
        "q": "¬øC√≥mo puedo comprobar si un objeto es una instancia de una clase dada o de una subclase de la misma?",
        "a": "Use the built-in function isinstance(obj, cls). You can check if an object is an instance of any of a number of classes by providing a tuple instead of a single class, e.g. isinstance(obj, (class1, class2, ...)), and can also check whether an object is one of Python‚Äôs built-in types, e.g. isinstance(obj, str) or isinstance(obj, (int, float, complex)).\nNote que isinstance() tambi√©n verifica la herencia virtual de una abstract base class. Entonces, la prueba retorna True para una clase registrada incluso si no ha heredado directa o indirectamente de ella. Para verificar ¬´herencia verdadera¬ª, escanea el MRO de la clase:\nfrom collections.abc import Mapping\nclass P:\npass\nclass C(P):\npass\nMapping.register(P)\nc = C()\nisinstance(c, C)        # direct\nTrue\nisinstance(c, P)        # indirect\nTrue\nisinstance(c, Mapping)  # virtual\nTrue\n# Actual inheritance chain\ntype(c).__mro__\n(<class 'C'>, <class 'P'>, <class 'object'>)\n# Test for \"true inheritance\"\nMapping in type(c).__mro__\nFalse\nDestacar que muchos programas no necesitan usar isinstance() de forma frecuente en clases definidas por el usuario. Si est√°s desarrollando clases un mejor estilo orientado a objetos ser√≠a el de definir los m√©todos en las clases que encapsulan un comportamiento en particular en lugar de ir comprobando la clase del objeto e ir haciendo cosas en base a la clase que es. Por ejemplo, si tienes una funci√≥n que hace lo siguiente:\ndef search(obj):\nif isinstance(obj, Mailbox):\n...  # code to search a mailbox\nelif isinstance(obj, Document):\n...  # code to search a document\nelif ...\nUn enfoque m√°s adecuado ser√≠a definir un m√©todo search() en todas las clases e invocarlo:\nclass Mailbox:\ndef search(self):\n...  # code to search a mailbox\nclass Document:\ndef search(self):\n...  # code to search a document\nobj.search()"
    },
    {
        "q": "¬øQu√© es la delegaci√≥n?",
        "a": "La delegaci√≥n es una t√©cnica orientada a objetos (tambi√©n llamado un patr√≥n de dise√±o). Digamos que tienes un objeto x y deseas cambiar el comportamiento de solo uno de sus m√©todos. Puedes crear una nueva clase que proporciona una nueva implementaci√≥n del m√©todo que te interesa cambiar y delega el resto de m√©todos al m√©todo correspondiente de x.\nLos programadores Python pueden implementar la delegaci√≥n de forma muy sencilla. Por ejemplo, la siguiente clase implementa una clase que se comporta como un fichero pero convierte todos los datos escritos a may√∫sculas:\nclass UpperOut:\ndef __init__(self, outfile):\nself._outfile = outfile\ndef write(self, s):\nself._outfile.write(s.upper())\ndef __getattr__(self, name):\nreturn getattr(self._outfile, name)\nHere the UpperOut class redefines the write() method to convert the argument string to uppercase before calling the underlying self._outfile.write() method. All other methods are delegated to the underlying self._outfile object. The delegation is accomplished via the __getattr__() method; consult the language reference for more information about controlling attribute access.\nNote that for more general cases delegation can get trickier. When attributes must be set as well as retrieved, the class must define a __setattr__() method too, and it must do so carefully. The basic implementation of __setattr__() is roughly equivalent to the following:\nclass X:\n...\ndef __setattr__(self, name, value):\nself.__dict__[name] = value\n...\nMany __setattr__() implementations call object.__setattr__() to set an attribute on self without causing infinite recursion:\nclass X:\ndef __setattr__(self, name, value):\n# Custom logic here...\nobject.__setattr__(self, name, value)\nAlternatively, it is possible to set attributes by inserting entries into self.__dict__ directly."
    },
    {
        "q": "¬øC√≥mo invoco a un m√©todo definido en una clase base desde una clase derivada que la extiende?",
        "a": "Usa la funci√≥n incorporada super():\nclass Derived(Base):\ndef meth(self):\nsuper().meth()  # calls Base.meth\nEn el ejemplo, super() autom√°ticamente determinar√° la instancia desde la cual ha sido llamada (el valor self`), busca el method resolution order (MRO) con type(self).__mro__, y devuelve el siguiente en l√≠nea despu√©s de Derived en el MRO: Base."
    },
    {
        "q": "¬øC√≥mo puedo organizar mi c√≥digo para hacer que sea m√°s sencillo modificar la clase base?",
        "a": "Puede asignar la clase base a un alias y derivar del alias. Entonces todo lo que tiene que cambiar es el valor asignado al alias. Por cierto, este truco tambi√©n es √∫til si desea decidir din√°micamente (por ejemplo, dependiendo de la disponibilidad de recursos) qu√© clase base usar. Ejemplo:\nclass Base:\n...\nBaseAlias = Base\nclass Derived(BaseAlias):\n..."
    },
    {
        "q": "¬øC√≥mo puedo crear datos est√°ticos de clase y m√©todos est√°ticos de clase?",
        "a": "Tanto los datos est√°ticos como los m√©todos est√°ticos (en el sentido de C++ o Java) est√°n permitidos en Python.\nPara datos est√°ticos simplemente define un atributo de clase. Para asignar un nuevo valor al atributo debes usar de forma expl√≠cita el nombre de la clase en la asignaci√≥n:\nclass C:\ncount = 0   # number of times C.__init__ called\ndef __init__(self):\nC.count = C.count + 1\ndef getcount(self):\nreturn C.count  # or return self.count\nc.count tambi√©n se refiere a C.count para cualquier c de tal forma que se cumpla isinstance(c, C), a no ser que c sea sobreescrita por si misma o por alguna clase contenida en la b√∫squeda de clases base desde c.__class__ hasta C.\nDebes tener cuidado: dentro de un m√©todo de C, una asignaci√≥n como self.count = 42 crear√° una nueva instancia sin relaci√≥n con la original que se llamar√° ¬´count¬ª en el propio diccionario de self. El reunificar el nombre de datos est√°ticos de una clase deber√≠a llevar, siempre, a especificar la clase tanto si se produce desde dentro de un m√©todo como si no:\nC.count = 314\nLos m√©todos est√°ticos son posibles:\nclass C:\n@staticmethod\ndef static(arg1, arg2, arg3):\n# No 'self' parameter!\n...\nSin embargo, una forma m√°s directa de obtener el efecto de un m√©todo est√°tico ser√≠a mediante una simple funci√≥n a nivel de m√≥dulo:\ndef getcount():\nreturn C.count\nSi has estructurado tu c√≥digo para definir una clase √∫nica (o una jerarqu√≠a de clases altamente relacionadas) por m√≥dulo, esto proporcionar√° la encapsulaci√≥n deseada."
    },
    {
        "q": "¬øComo puedo sobrecargar constructores (o m√©todos) en Python?",
        "a": "Esta respuesta es aplicable, en realidad, a todos los m√©todos pero la pregunta suele surgir primero en el contexto de los constructores.\nEn C++ deber√≠as escribir\nclass C {\nC() { cout << \"No arguments\n\"; }\nC(int i) { cout << \"Argument is \" << i << \"\n\"; }\n}\nEn Python solo debes escribir un √∫nico constructor que tenga en cuenta todos los casos usando los argumentos por defecto. Por ejemplo:\nclass C:\ndef __init__(self, i=None):\nif i is None:\nprint(\"No arguments\")\nelse:\nprint(\"Argument is\", i)\nEsto no es totalmente equivalente pero, en la pr√°ctica, es muy similar.\nPodr√≠as intentar, tambi√©n una lista de argumentos de longitud variable, por ejemplo\ndef __init__(self, *args):\n...\nEl mismo enfoque funciona para todas las definiciones de m√©todos.\nIntento usar __spam y obtengo un error sobre _SomeClassName__spam.\nNombres de variable con doble gui√≥n prefijado se convierten, con una modificaci√≥n de nombres, para proporcionar una forma simple pero efectiva de definir variables de clase privadas. Cualquier identificador de la forma __spam (como m√≠nimo dos guiones bajos como prefijo, como m√°ximo un gui√≥n bajo como sufijo) se reemplaza con _classname__spam, donde classname es el nombre de la clase eliminando cualquier gui√≥n bajo prefijado.\nThe identifier can be used unchanged within the class, but to access it outside the class, the mangled name must be used:\nclass A:\ndef __one(self):\nreturn 1\ndef two(self):\nreturn 2 * self.__one()\nclass B(A):\ndef three(self):\nreturn 3 * self._A__one()\nfour = 4 * A()._A__one()\nIn particular, this does not guarantee privacy since an outside user can still deliberately access the private attribute; many Python programmers never bother to use private variable names at all.\nVer tambi√©n The private name mangling specifications for details and special cases.\nMi clase define __del__ pero no se le invoca cuando borro el objeto.\nExisten varias razones posibles para que suceda as√≠.\nThe del statement does not necessarily call __del__() ‚Äì it simply decrements the object‚Äôs reference count, and if this reaches zero __del__() is called.\nIf your data structures contain circular links (e.g. a tree where each child has a parent reference and each parent has a list of children) the reference counts will never go back to zero. Once in a while Python runs an algorithm to detect such cycles, but the garbage collector might run some time after the last reference to your data structure vanishes, so your __del__() method may be called at an inconvenient and random time. This is inconvenient if you‚Äôre trying to reproduce a problem. Worse, the order in which object‚Äôs __del__() methods are executed is arbitrary. You can run gc.collect() to force a collection, but there are pathological cases where objects will never be collected.\nDespite the cycle collector, it‚Äôs still a good idea to define an explicit close() method on objects to be called whenever you‚Äôre done with them. The close() method can then remove attributes that refer to subobjects. Don‚Äôt call __del__() directly ‚Äì __del__() should call close() and close() should make sure that it can be called more than once for the same object.\nOtra forma de evitar referencias c√≠clicas ser√≠a usando el m√≥dulo weakref, que permite apuntar hacia objetos sin incrementar su conteo de referencias. Las estructuras de datos en √°rbol, por ejemplo, deber√≠an usar referencias d√©biles para las referencias del padre y hermanos (¬°si es que las necesitan!).\nFinally, if your __del__() method raises an exception, a warning message is printed to sys.stderr."
    },
    {
        "q": "¬øC√≥mo puedo obtener una lista de todas las instancias de una clase dada?",
        "a": "Python no hace seguimiento de todas las instancias de una clase (o de los tipos incorporados). Puedes programar el constructor de una clase para que haga seguimiento de todas sus instancias manteniendo una lista de referencias d√©biles a cada instancia."
    },
    {
        "q": "¬øPor qu√© el resultado de id() no parece ser √∫nico?",
        "a": "La funci√≥n incorporada id() devuelve un entero que se garantiza que sea √∫nico durante la vida del objeto. Debido a que en CPython esta es la direcci√≥n en memoria del objeto, sucede que, frecuentemente, despu√©s de que un objeto se elimina de la memoria el siguiente objeto reci√©n creado se localiza en la misma posici√≥n en memoria. Esto se puede ver ilustrado en este ejemplo:\nid(1000)\n13901272\nid(2000)\n13901272\nLas dos ids pertenecen a dos objetos ‚Äúentero‚Äù diferentes que se crean antes y se eliminan inmediatamente despu√©s de la ejecuci√≥n de la invocaci√≥n a id(). Para estar seguro que los objetos cuya id quieres examinar siguen vivos crea otra referencia al objeto:\na = 1000; b = 2000\nid(a)\n13901272\nid(b)\n13891296"
    },
    {
        "q": "¬øCu√°ndo puedo fiarme de pruebas de identidad con el operador is?",
        "a": "El operador is verifica la identidad de un objeto. La prueba a is b es equivalente a id(a) == id(b).\nLa propiedad m√°s importante de una prueba de identidad es que un objeto siempre es id√©ntico a si mismo, a is a siempre devuelve True. Las pruebas de identidad suelen ser m√°s r√°pidas que pruebas de igualdad. Y a diferencia de las pruebas de igualdad, las pruebas de identidad est√°n garantizadas de devolver un booleano True o False.\nSin embargo, las pruebas de identidad solo pueden ser sustituidas por pruebas de igualdad cuando la identidad de objeto est√° asegurada. Generalmente hay tres circunstancias en las que la identidad est√° garantizada:\nAssignments create new names but do not change object identity. After the assignment new = old, it is guaranteed that new is old.\nPutting an object in a container that stores object references does not change object identity. After the list assignment s[0] = x, it is guaranteed that s[0] is x.\nIf an object is a singleton, it means that only one instance of that object can exist. After the assignments a = None and b = None, it is guaranteed that a is b because None is a singleton.\nEn la mayor√≠a de las dem√°s circunstancias, no se recomiendan las pruebas de identidad y las pruebas de igualdad son preferidas. En particular, las pruebas de identidad no deben ser usadas para verificar constantes como int y str que no est√°n garantizadas a ser singletons:\na = 1000\nb = 500\nc = b + 500\na is c\nFalse\na = 'Python'\nb = 'Py'\nc = b + 'thon'\na is c\nFalse\nDe la misma manera, nuevas instancias de contenedores mutables nunca son id√©nticas:\na = []\nb = []\na is b\nFalse\nEn la librer√≠a est√°ndar de c√≥digo, ver√°s varios patrones comunes para usar correctamente pruebas de identidad:\nAs recommended by PEP 8, an identity test is the preferred way to check for None. This reads like plain English in code and avoids confusion with other objects that may have boolean values that evaluate to false.\nDetecting optional arguments can be tricky when None is a valid input value. In those situations, you can create a singleton sentinel object guaranteed to be distinct from other objects. For example, here is how to implement a method that behaves like dict.pop():\n_sentinel = object()\ndef pop(self, key, default=_sentinel):\nif key in self:\nvalue = self[key]\ndel self[key]\nreturn value\nif default is _sentinel:\nraise KeyError(key)\nreturn default\nContainer implementations sometimes need to augment equality tests with identity tests. This prevents the code from being confused by objects such as float('NaN') that are not equal to themselves.\nFor example, here is the implementation of collections.abc.Sequence.__contains__():\ndef __contains__(self, value):\nfor v in self:\nif v is value or v == value:\nreturn True\nreturn False"
    },
    {
        "q": "¬øC√≥mo puede una subclase controlar qu√© datos se almacenan en una instancia inmutable?",
        "a": "When subclassing an immutable type, override the __new__() method instead of the __init__() method. The latter only runs after an instance is created, which is too late to alter data in an immutable instance.\nTodas estas clases inmutables tienen una firma distinta que su clase padre:\nfrom datetime import date\nclass FirstOfMonthDate(date):\n\"Always choose the first day of the month\"\ndef __new__(cls, year, month, day):\nreturn super().__new__(cls, year, month, 1)\nclass NamedInt(int):\n\"Allow text names for some numbers\"\nxlat = {'zero': 0, 'one': 1, 'ten': 10}\ndef __new__(cls, value):\nvalue = cls.xlat.get(value, value)\nreturn super().__new__(cls, value)\nclass TitleStr(str):\n\"Convert str to name suitable for a URL path\"\ndef __new__(cls, s):\ns = s.lower().replace(' ', '-')\ns = ''.join([c for c in s if c.isalnum() or c == '-'])\nreturn super().__new__(cls, s)\nLas clases pueden ser utilizadas as√≠:\nFirstOfMonthDate(2012, 2, 14)\nFirstOfMonthDate(2012, 2, 1)\nNamedInt('ten')\n10\nNamedInt(20)\n20\nTitleStr('Blog: Why Python Rocks')\n'blog-why-python-rocks'\n'blog-why-python-rocks'"
    },
    {
        "q": "¬øC√≥mo cacheo llamadas de m√©todo?",
        "a": "Las dos herramientas principales para cachear m√©todos son functools.cached_property() y functools.lru_cache(). El primero guarda resultados a nivel de instancia y el √∫ltimo a nivel de clase.\nLa funci√≥n cached_property s√≥lo funciona con m√©todos que no acepten argumentos. No crea una referencia a la instancia. El resultado del m√©todo cacheado se mantendr√° solo mientras que la instancia est√© activa.\nThe advantage is that when an instance is no longer used, the cached method result will be released right away. The disadvantage is that if instances accumulate, so too will the accumulated method results. They can grow without bound.\nThe lru_cache approach works with methods that have hashable arguments. It creates a reference to the instance unless special efforts are made to pass in weak references.\nLa ventaja del algoritmo usado menos recientemente es que el cache est√° limitado por el maxsize especificado. La desventaja es que las instancias se mantienen activas hasta que sean eliminadas del cache por edad o que el cache sea borrado.\nEste ejemplo muestra las diversas t√©cnicas:\nclass Weather:\n\"Lookup weather information on a government website\"\ndef __init__(self, station_id):\nself._station_id = station_id\n# The _station_id is private and immutable\ndef current_temperature(self):\n\"Latest hourly observation\"\n# Do not cache this because old results\n# can be out of date.\n@cached_property\ndef location(self):\n\"Return the longitude/latitude coordinates of the station\"\n# Result only depends on the station_id\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='mm'):\n\"Rainfall on a given date\"\n# Depends on the station_id, date, and units.\nEl ejemplo anterior asume que la station_id nunca cambia. Si los atributos de la instancia relevante son mutables, el m√©todo de cached_property no puede funcionar porque no puede detectar cambios en los atributos.\nTo make the lru_cache approach work when the station_id is mutable, the class needs to define the __eq__() and __hash__() methods so that the cache can detect relevant attribute updates:\nclass Weather:\n\"Example with a mutable station identifier\"\ndef __init__(self, station_id):\nself.station_id = station_id\ndef change_station(self, station_id):\nself.station_id = station_id\ndef __eq__(self, other):\nreturn self.station_id == other.station_id\ndef __hash__(self):\nreturn hash(self.station_id)\n@lru_cache(maxsize=20)\ndef historic_rainfall(self, date, units='cm'):\n'Rainfall on a given date'\n# Depends on the station_id, date, and units.\nM√≥dulos"
    },
    {
        "q": "¬øC√≥mo creo un fichero .pyc?",
        "a": "Cuando se importa un m√≥dulo por primera vez (o cuando el fichero fuente ha cambiado desde que se cre√≥ el fichero compilado actual) un fichero .pyc conteniendo el c√≥digo compilado deber√≠a crearse en un subdirectorio __pycache__ del directorio que contiene el fichero .py. El fichero .pyc tendr√° un nombre que comienza con el mismo nombre que el fichero .py y finaliza con .pyc, con un componente intermedio que depende del binario python particular que lo cre√≥. (Ver PEP 3147 para m√°s detalles.)\nUna raz√≥n por la que un fichero .pyc puede no crearse es por un problema de permisos con el directorio que contiene el fichero fuente, lo que provoca que el subdirectorio __pycache__ no se pueda crear. Esto puede suceder, por ejemplo, si desarrollas como un usuario pero ejecutas como otro, como si estuvieras probando con un servidor web.\nA menos que la variable de entorno PYTHONDONTWRITEBYTECODE est√© configurada, la creaci√≥n de un fichero .pyc es autom√°tica si est√°s importando un m√≥dulo y Python tiene la habilidad (permisos, espacio libre, etc‚Ä¶) para crear un subdirectorio __pycache__ y escribir el m√≥dulo compilado en ese subdirectorio.\nEjecutar Python en un script de nivel superior no se considera una importaci√≥n y no se crea un .pyc. Por ejemplo, si tiene un m√≥dulo de nivel superior foo.py que importa otro m√≥dulo xyz.py, cuando ejecuta foo, se crear√° un .pyc para xyz ya que se importa xyz, pero no se crea ning√∫n archivo .pyc para foo ya que foo.py no se est√° importando.\nSi necesitas crear un fichero .pyc para foo ‚Äì esto es, crear un fichero .pyc para un m√≥dulo que no ha sido importado ‚Äì puedes usar los m√≥dulos py_compile y compileall.\nEl m√≥dulo py_compile puede compilar manualmente cualquier m√≥dulo. Una forma es usar la funci√≥n compile() en ese m√≥dulo de forma interactiva:\nimport py_compile\npy_compile.compile('foo.py')\nEsto escribir√° el .pyc en el subdirectorio __pycache__ en la misma ubicaci√≥n que foo.py (o puedes anularlo con el par√°metro opcional cfile).\nTambi√©n puedes compilar autom√°ticamente todos los ficheros en un directorio o directorios usando el m√≥dulo compileall. Puedes hacerlo desde la l√≠nea de comandos ejecutando compileall.py y proporcionando la ruta del directorio que contiene los ficheros Python a compilar:\npython -m compileall ."
    },
    {
        "q": "¬øC√≥mo encuentro el nombre del m√≥dulo actual?",
        "a": "Un m√≥dulo puede encontrar su propio nombre mirando la variable global __name__. Si tiene el valor '__main__', el programa se est√° ejecutando como un script. Muchos m√≥dulos que se usan habitualmente para importar tambi√©n proporcionan una interfaz de l√≠nea de comandos o una autocomprobaci√≥n y solo ejecutan este c√≥digo despu√©s de comprobar __name__:\ndef main():\nprint('Running test...')\n...\nif __name__ == '__main__':\nmain()"
    },
    {
        "q": "¬øC√≥mo puedo tener m√≥dulos que se importen mutuamente?",
        "a": "Sup√≥n que tienes los siguientes m√≥dulos:\nfoo.py:\nfrom bar import bar_var\nfoo_var = 1\nbar.py:\nfrom foo import foo_var\nbar_var = 2\nEl problema es que el int√©rprete realizar√° los siguientes pasos:\nmain importa foo\nSe crean variables globales vac√≠as para foo\nfoo se compila y comienza a ejecutarse\nfoo importa bar\nSe crean variables globales vac√≠as para bar\nbar se compila y comienza a ejecutarse\nbar importa foo (lo cual es una no-operaci√≥n ya que ya existe un m√≥dulo llamado foo)\nbar.foo_var = foo.foo_var\nEl √∫ltimo paso falla porque Python a√∫n no ha terminado de interpretar foo y el diccionario de s√≠mbolos global para foo todav√≠a est√° vac√≠o.\nLo mismo sucede cuando usas import foo y despu√©s intentas acceder a foo.foo_var en el c√≥digo global.\nExisten (al menos) tres posibles soluciones para este problema.\nGuido van Rossum recomienda evitar el uso de from <module> import ... y colocar todo el c√≥digo dentro de funciones. La inicializaci√≥n de variables globales y variables de clase solo deber√≠a usar constantes o funciones integradas. Esto significa que todo desde un m√≥dulo importado se referencia como <module>.<name>.\nJim Roskind sugiere realizar los pasos siguientes en cada m√≥dulo en el orden siguiente:\nexportaciones (globales, funciones y clases que no necesitan clases base importadas)\nsentencias import\nc√≥digo activo (incluyendo globales que se inicializan desde m√≥dulos importados).\nVan Rossum no termina de estar de acuerdo con este enfoque porque las importaciones aparecen en un lugar extra√±o pero funciona.\nMatthias Urlichs recomienda reestructurar tu c√≥digo de tal forma que la importaci√≥n recursiva no sea necesaria.\nEstas soluciones no son mutuamente excluyentes."
    },
    {
        "q": "__import__('x.y.z') devuelve <module 'x'>; ¬øc√≥mo obtengo z?",
        "a": "Considera usar la funci√≥n de conveniencia import_module() desde importlib en su lugar:\nz = importlib.import_module('x.y.z')"
    },
    {
        "q": "¬øCuando edito un m√≥dulo importado y lo reimporto, los cambios no se muestran. ¬øPor qu√© sucede esto?",
        "a": "Por razones de eficiencia y consistencia, Python solo lee el fichero del m√≥dulo la primera vez que se importa un m√≥dulo. Si no fuera as√≠, en un programa que constara de muchos m√≥dulos donde cada uno importa el mismo m√≥dulo b√°sico, el m√≥dulo b√°sico ser√≠a analizado y re-analizado muchas veces. Para forzar la relectura de un m√≥dulo que ha cambiado haz esto:\nimport importlib\nimport modname\nimportlib.reload(modname)\nAdvertencia: esta t√©cnica no es 100% infalible. En particular, los m√≥dulos que contienen declaraciones como\nfrom modname import some_objects\nseguir√°n trabajando con la versi√≥n antigua de los objetos importados. Si el m√≥dulo contiene definiciones de clase, las instancias de clase existentes no se actualizar√°n para usar la nueva definici√≥n de clase. Esto puede resultar en el siguiente comportamiento parad√≥jico:\nimport importlib\nimport modname\nimportlib.reload(modname)\n# <make a new instance of a class in modname>\nc = modname.C()\n# <create an object of the same class using an existing instance>\nd = c.__class__()\n# <compare the two objects>\nc.__class__ is d.__class__\nTrue\nLa naturaleza del problema se clarifica si imprimes los objetos clase:\nprint(c.__class__, d.__class__)\n<class 'modname.C'> <class 'modname.C'>"
    }
];
